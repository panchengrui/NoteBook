# 一、数组

## 1.1 二分查找

> 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
>
> **示例 1:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1
> ```
>
> 
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

* **注意**

  **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

  二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

  写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

* **解题思路**

  第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：

  ![704.二分查找](https://img-blog.csdnimg.cn/20210311153055723.jpg)

```java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;
        if (nums == null || length == 0
            // 避免当target小于nums中的最小数或者大于最大数时多次循环
            || target < nums[0] || target > nums[length - 1]) {
            return -1;
        }
        int left = 0;
        // (1)
        int right = length - 1;
        // (2) 注意这里写得是 <= , 当然也可以写成 < , 不过(1)处要改为right=length，（3）处要改为right=mid
        while (left <= right) {
            int mid = left + ((right - left) / 2);
            if (target == nums[mid]) {
                return mid;
            }
            else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                // （3）
                right = mid - 1;
            }
        }
        return -1;
    }
}
```



## 1.2 移除元素

> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 
>
> **说明:**
>
> 为什么返回数值是整数，但输出的答案是数组呢?
>
> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> ```
> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
> int len = removeElement(nums, val);
> 
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>  print(nums[i]);
> }
> ```
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2]
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
> ```
>
> 
>
> **提示：**
>
> - `0 <= nums.length <= 100`
> - `0 <= nums[i] <= 50`
> - `0 <= val <= 100`
>
> Related Topics：数组、双指针

* **解题思路**

  使用快慢指针的方法，快指针是循环的变量，每次循环将指针向前移动，

  慢指针是新数组的下标

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新 新数组下标的位置

  ![](https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif#pic_center)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (val != nums[fast]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
}
```



## 1.3 有组数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
>
> 
>
> **示例 1：**
>
> ```
>输入：nums = [-4,-1,0,3,10]
> 输出：[0,1,9,16,100]
> 解释：平方后，数组变为 [16,1,0,9,100]
> 排序后，数组变为 [0,1,9,16,100]
> ```
> 
> **示例 2：**
>
> ```
>输入：nums = [-7,-3,2,3,11]
> 输出：[4,9,9,49,121]
> ```
> 
> 
>
> **提示：**
>
> - `1 <= nums.length <= 104`
>- `-104 <= nums[i] <= 104`
> - `nums` 已按 **非递减顺序** 排序
> 
> 
>
> **进阶：**
>
> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题
>
> Related Topics：数组、双指针、排序

* **解题思路**

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

  如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

  如动画所示：

  ![](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif#pic_center)

  

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] newArr = new int[nums.length];
        int left = 0, right = nums.length - 1, newArrIndex = right;
        while (left <= right) {
            int lNum = nums[left] * nums[left];
            int rNum = nums[right] * nums[right];
            if (lNum > rNum) {
                newArr[newArrIndex--] = lNum;
                ++left;
            } else {
                newArr[newArrIndex--] = rNum;
                --right;
            }
        }
        return newArr;
    }
}
```



## 1.4 长度最小的子数组

> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
> 找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> ```
>
> **示例 2：**
>
> ```
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
> ```
>
> 
>
> **提示：**
>
> - `1 <= target <= 109`
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 105`
>
> 
>
> **进阶：**
>
> - 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。
>
> Related Topics：数组、滑动窗口

* **解题思路**

  滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

  在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

  那么滑动窗口如何用一个for循环来完成这个操作呢。

  首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

  如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？

  此时难免再次陷入 暴力解法的怪圈。

  所以 只用一个for循环，那么这个**循环的索引，一定是表示 滑动窗口的终止位置**。

  那么问题来了， 滑动窗口的起始位置如何移动呢？

  这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

  ![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

  最后找到 4，3 是最短距离。

  其实从动画中可以发现**滑动窗口也可以理解为双指针法的一种**！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？
  - 如何移动窗口的起始位置？
  - 如何移动窗口的结束位置？

  **窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。**

  **窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。**

  **窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。**

  解题的关键在于 窗口的起始位置如何移动，如图所示：

  ![leetcode_209](https://img-blog.csdnimg.cn/20210312160441942.png)

  可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minLen = Integer.MAX_VALUE;
        // 外层循环中的索引控制的是滑动窗口的结束位置
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                minLen = Math.min(minLen, right - left + 1);
                // 这里体现出滑动窗口的精髓之处，不断变更窗口的起始位置
                sum -= nums[left++];
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```



# 二、链表

## 2.1 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)
>
> ```
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [], val = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [7,7,7,7], val = 7
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 列表中的节点数目在范围 `[0, 104]` 内
> - `1 <= Node.val <= 50`
> - `0 <= val <= 50`

* **解题思路**

  **可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

  来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。

  ![203_链表删除元素6](https://img-blog.csdnimg.cn/20210316095619221.png)

  这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。

  这样是不是就可以使用和移除链表其他节点的方式统一了呢？

  来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。

  最后呢在题目中，return 头结点的时候，别忘了 `return dummyNode->next;`， 这才是新的头结点

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        ListNode cur = head;
        while (cur != null) {
            if (cur.val == val) {
                pre.next = cur.next;
            } else {
                // 注意这里的 pre = cur 要写在else分支中，而不是和下面的 cur = cur.next放在一起，如示例3，存在多个需要删除的值连续的情况，pre可以理解为新链表的元素下标，如果当前值和目标值不相等时，也就是该值应该保留，才应该将pre向后移一位，否则应该保留当前的下标位置
                pre = cur;
            }
            cur = cur.next;
        }
        // 应注意这里返回的是dummy.next，而不是head
        return dummy.next;
    }
}
```



## 2.2 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)
>
> ```
> 输入：head = [1,2]
> 输出：[2,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>
> 
>
> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

* **解题思路**

  我们拿有示例中的链表来举例，如动画所示：（纠正：动画应该是先移动pre，在移动cur）

  ![img](https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

  首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

  然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

  为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

  接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

  最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

  递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 解法一：双指针
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;

        // 解法二：递归
        return reverse(null, head);
    }

    private ListNode reverse(ListNode pre, ListNode cur) {
        if (cur == null) {
            return pre;
        }
        ListNode temp = cur.next;
        cur.next = pre;
        /*pre = cur;
            cur = temp;
            return reverse(pre, cur);*/
        // 等同于上面的代码
        return reverse(cur, temp);
    }
}
```



## 2.3 两两交换链表中的节点

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1]
> 输出：[1]
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目在范围 `[0, 100]` 内
> - `0 <= Node.val <= 100`

* **解题思路**

  建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

  对虚拟头结点的操作，还不熟悉的话，可以看这篇[链表：听说用虚拟头节点会方便很多？ (opens new window)](https://programmercarl.com/0203.移除链表元素.html)。

  接下来就是交换相邻两个元素了，**此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序**

  初始时，cur指向虚拟头结点，然后进行如下三步：

  ![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

  操作之后，链表如下：

  ![24.两两交换链表中的节点2](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png)

  看这个可能就更直观一些了：

  ![24.两两交换链表中的节点3](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        while (pre.next != null && pre.next.next != null) {
            // 缓存next
            ListNode temp = head.next.next;
            pre.next = head.next;
            head.next.next = head;
            // 将head的next接上缓存的temp
            head.next = temp;
            // 步进一位
            pre = head;
            head = head.next;
        }
        return dummy.next;
    }
}
```



## 2.4 删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [1], n = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1,2], n = 1
> 输出：[1]
> ```
>
> 
>
> **提示：**
>
> - 链表中结点的数目为 `sz`
> - `1 <= sz <= 30`
> - `0 <= Node.val <= 100`
> - `1 <= n <= sz`
>
> 
>
> **进阶：**你能尝试使用一趟扫描实现吗？
>
> Related Topics：链表、双指针

* **解题思路**

  双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

  思路是这样的，但要注意一些细节。

  分为如下几步：

  - 首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： [链表：听说用虚拟头节点会方便很多？(opens new window)](https://programmercarl.com/0203.移除链表元素.html)
  - 定义fast指针和slow指针，初始值为虚拟头结点，如图：

  ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

  - fast首先走**n + 1**步 ，**为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点**（方便做删除操作），如图： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)
  - fast和slow同时移动，直到fast指向末尾，如题： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)
  - 删除slow指向的下一个节点，如图： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

```Java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode slow = dummy, fast = dummy;
        for (int i = 0; i < n + 1; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

