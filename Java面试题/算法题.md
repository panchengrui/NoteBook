面试官您好，我叫潘承瑞，去年硕士毕业于中国计量大学，目前在杭州海康威视任Java后端开发一职。在这一年多的工作中，我主要负责组内一个新平台的开发工作，平台的主要功能是为测试人员提供一个高度集成化的一站式测试平台，供其能在页面上自主编排测试流程，而后以多种方式复用执行。我是该项目的主要开发者，我参与了包括执行引擎、参数替换、执行日志等多个核心功能的设计开发工作。我的项目经验不是很丰富，但平常工作中我比较有代码质量意识，会不断学习新的知识来提升自己的代码质量。

# 一、数组

## 1.1 二分查找

> 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
>
> **示例 1:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1
> ```
>
> 
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

* **注意**

  **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

  二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

  写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

* **解题思路**

  第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：

  ![704.二分查找](https://img-blog.csdnimg.cn/20210311153055723.jpg)

```java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;
        if (nums == null || length == 0
            // 避免当target小于nums中的最小数或者大于最大数时多次循环
            || target < nums[0] || target > nums[length - 1]) {
            return -1;
        }
        int left = 0;
        // (1)
        int right = length - 1;
        // (2) 注意这里写得是 <= , 当然也可以写成 < , 不过(1)处要改为right=length，（3）处要改为right=mid
        while (left <= right) {
            int mid = left + ((right - left) / 2);
            if (target == nums[mid]) {
                return mid;
            }
            else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                // （3）
                right = mid - 1;
            }
        }
        return -1;
    }
}
```



## 1.2 移除元素

> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 
>
> **说明:**
>
> 为什么返回数值是整数，但输出的答案是数组呢?
>
> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> ```
> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
> int len = removeElement(nums, val);
> 
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>  print(nums[i]);
> }
> ```
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2]
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
> ```
>
> 
>
> **提示：**
>
> - `0 <= nums.length <= 100`
> - `0 <= nums[i] <= 50`
> - `0 <= val <= 100`
>
> Related Topics：数组、双指针

* **解题思路**

  使用快慢指针的方法，快指针是循环的变量，每次循环将指针向前移动，

  慢指针是新数组的下标

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新 新数组下标的位置

  ![](https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif#pic_center)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (val != nums[fast]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
}
```



## 1.3 有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
>
> 
>
> **示例 1：**
>
> ```
>输入：nums = [-4,-1,0,3,10]
> 输出：[0,1,9,16,100]
> 解释：平方后，数组变为 [16,1,0,9,100]
> 排序后，数组变为 [0,1,9,16,100]
> ```
> 
> **示例 2：**
>
> ```
>输入：nums = [-7,-3,2,3,11]
> 输出：[4,9,9,49,121]
> ```
> 
> 
>
> **提示：**
>
> - `1 <= nums.length <= 104`
>- `-104 <= nums[i] <= 104`
> - `nums` 已按 **非递减顺序** 排序
> 
> 
>
> **进阶：**
>
> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题
>
> Related Topics：数组、双指针、排序

* **解题思路**

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

  如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

  如动画所示：

  ![](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif#pic_center)

  

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] newArr = new int[nums.length];
        int left = 0, right = nums.length - 1, newArrIndex = right;
        while (left <= right) {
            int lNum = nums[left] * nums[left];
            int rNum = nums[right] * nums[right];
            if (lNum > rNum) {
                newArr[newArrIndex--] = lNum;
                ++left;
            } else {
                newArr[newArrIndex--] = rNum;
                --right;
            }
        }
        return newArr;
    }
}
```



## 1.4 长度最小的子数组

> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
> 找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> ```
>
> **示例 2：**
>
> ```
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
> ```
>
> 
>
> **提示：**
>
> - `1 <= target <= 109`
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 105`
>
> 
>
> **进阶：**
>
> - 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。
>
> Related Topics：数组、滑动窗口

* **解题思路**

  滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

  在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

  那么滑动窗口如何用一个for循环来完成这个操作呢。

  首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

  如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？

  此时难免再次陷入 暴力解法的怪圈。

  所以 只用一个for循环，那么这个**循环的索引，一定是表示 滑动窗口的终止位置**。

  那么问题来了， 滑动窗口的起始位置如何移动呢？

  这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

  ![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

  最后找到 4，3 是最短距离。

  其实从动画中可以发现**滑动窗口也可以理解为双指针法的一种**！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？
  - 如何移动窗口的起始位置？
  - 如何移动窗口的结束位置？

  **窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。**

  **窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。**

  **窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。**

  解题的关键在于 窗口的起始位置如何移动，如图所示：

  ![leetcode_209](https://img-blog.csdnimg.cn/20210312160441942.png)

  可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minLen = Integer.MAX_VALUE;
        // 外层循环中的索引控制的是滑动窗口的结束位置
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                minLen = Math.min(minLen, right - left + 1);
                // 这里体现出滑动窗口的精髓之处，不断变更窗口的起始位置
                sum -= nums[left++];
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```



# 二、链表

## 2.1 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)
>
> ```
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [], val = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [7,7,7,7], val = 7
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 列表中的节点数目在范围 `[0, 104]` 内
> - `1 <= Node.val <= 50`
> - `0 <= val <= 50`

* **解题思路**

  **可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

  来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。

  ![203_链表删除元素6](https://img-blog.csdnimg.cn/20210316095619221.png)

  这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。

  这样是不是就可以使用和移除链表其他节点的方式统一了呢？

  来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。

  最后呢在题目中，return 头结点的时候，别忘了 `return dummyNode->next;`， 这才是新的头结点

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        ListNode cur = head;
        while (cur != null) {
            if (cur.val == val) {
                pre.next = cur.next;
            } else {
                // 注意这里的 pre = cur 要写在else分支中，而不是和下面的 cur = cur.next放在一起，如示例3，存在多个需要删除的值连续的情况，pre可以理解为新链表的元素下标，如果当前值和目标值不相等时，也就是该值应该保留，才应该将pre向后移一位，否则应该保留当前的下标位置
                pre = cur;
            }
            cur = cur.next;
        }
        // 应注意这里返回的是dummy.next，而不是head
        return dummy.next;
    }
}
```



## 2.2 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)
>
> ```
> 输入：head = [1,2]
> 输出：[2,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>
> 
>
> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

* **解题思路**

  我们拿有示例中的链表来举例，如动画所示：（纠正：动画应该是先移动pre，在移动cur）

  ![img](https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

  首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

  然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

  为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

  接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

  最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

  递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 解法一：双指针
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;

        // 解法二：递归
        return reverse(null, head);
    }

    private ListNode reverse(ListNode pre, ListNode cur) {
        if (cur == null) {
            return pre;
        }
        ListNode temp = cur.next;
        cur.next = pre;
        /*pre = cur;
            cur = temp;
            return reverse(pre, cur);*/
        // 等同于上面的代码
        return reverse(cur, temp);
    }
}
```



## 2.3 两两交换链表中的节点

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1]
> 输出：[1]
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目在范围 `[0, 100]` 内
> - `0 <= Node.val <= 100`

* **解题思路**

  建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

  对虚拟头结点的操作，还不熟悉的话，可以看这篇[链表：听说用虚拟头节点会方便很多？ (opens new window)](https://programmercarl.com/0203.移除链表元素.html)。

  接下来就是交换相邻两个元素了，**此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序**

  初始时，cur指向虚拟头结点，然后进行如下三步：

  ![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

  操作之后，链表如下：

  ![24.两两交换链表中的节点2](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png)

  看这个可能就更直观一些了：

  ![24.两两交换链表中的节点3](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        while (pre.next != null && pre.next.next != null) {
            // 缓存next
            ListNode temp = head.next.next;
            pre.next = head.next;
            head.next.next = head;
            // 将head的next接上缓存的temp
            head.next = temp;
            // 步进一位
            pre = head;
            head = head.next;
        }
        return dummy.next;
    }
}
```



## 2.4 删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [1], n = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1,2], n = 1
> 输出：[1]
> ```
>
> 
>
> **提示：**
>
> - 链表中结点的数目为 `sz`
> - `1 <= sz <= 30`
> - `0 <= Node.val <= 100`
> - `1 <= n <= sz`
>
> 
>
> **进阶：**你能尝试使用一趟扫描实现吗？
>
> Related Topics：链表、双指针

* **解题思路**

  双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

  思路是这样的，但要注意一些细节。

  分为如下几步：

  - 首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： [链表：听说用虚拟头节点会方便很多？(opens new window)](https://programmercarl.com/0203.移除链表元素.html)
  - 定义fast指针和slow指针，初始值为虚拟头结点，如图：

  ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

  - fast首先走**n + 1**步 ，**为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点**（方便做删除操作），如图： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)
  - fast和slow同时移动，直到fast指向末尾，如题： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)
  - 删除slow指向的下一个节点，如图： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

```Java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode slow = dummy, fast = dummy;
        for (int i = 0; i < n + 1; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



# 三、哈希表

## 3.1 有效的字母异位词

> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。
>
> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。
>
> 
>
> **示例 1:**
>
> ```
> 输入: s = "anagram", t = "nagaram"
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "rat", t = "car"
> 输出: false
> ```
>
> 
>
> **提示:**
>
> - `1 <= s.length, t.length <= 5 * 104`
> - `s` 和 `t` 仅包含小写字母
>
> 
>
> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
>
> Related Topics：哈希表、字符串

* **解题思路**

  **数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。

  如果对哈希表的理论基础关于数组，set，map不了解的话可以看这篇：[关于哈希表，你该了解这些！(opens new window)](https://programmercarl.com/哈希表理论基础.html)

  需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。

  为了方便举例，判断一下字符串s= "aee", t = "eae"。

  操作动画如下：

  ![242.有效的字母异位词](https://tva1.sinaimg.cn/large/008eGmZEly1govxyg83bng30ds09ob29.gif)

  定义一个数组叫做record用来上记录字符串s里字符出现的次数。

  需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

  再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

  那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

  那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

  最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];

        for (int i = 0; i < s.length(); i++) {
            record[s.charAt(i) - 'a']++;
        }

        for (int i = 0; i < t.length(); i++) {
            record[t.charAt(i) - 'a']--;
        }
        
        for (int count: record) {
            if (count != 0) {
                return false;
            }
        }
        return true;
    }
}
```



## 3.2 两个数组的交集

> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
> 解释：[4,9] 也是可通过的
> ```
>
> 
>
> **提示：**
>
> - `1 <= nums1.length, nums2.length <= 1000`
> - `0 <= nums1[i], nums2[i] <= 1000`

* **解题思路**

  **如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

  此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：

  - std::set
  - std::multiset
  - std::unordered_set

  std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

  思路如图所示：

  ![set哈希法](https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png)

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        // 遍历数组1
        for (int i : nums1) {
            set1.add(i);
        }
        // 遍历数组2的过程中判断哈希表中是否存在该元素
        for (int i : nums2) {
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }
        // 将结果转为数组
        return resSet.stream().mapToInt(x -> x).toArray();
    }
}
```



## 3.3 快乐数

> 编写一个算法来判断一个数 `n` 是不是快乐数。
>
> **「快乐数」** 定义为：
>
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
>
> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：n = 19
> 输出：true
> 解释：
> 12 + 92 = 82
> 82 + 22 = 68
> 62 + 82 = 100
> 12 + 02 + 02 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 2
> 输出：false
> ```
>
> 
>
> **提示：**
>
> - `1 <= n <= 231 - 1`

* **解题思路**

  这道题目看上去貌似一道数学问题，其实并不是！

  题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

  正如：[关于哈希表，你该了解这些！ (opens new window)](https://programmercarl.com/哈希表理论基础.html)中所说，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

  所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。

  判断sum是否重复出现就可以使用unordered_set。

  **还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。**

```Java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```



## 3.4 四数相加

> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
>
> - `0 <= i, j, k, l < n`
> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 输出：2
> 解释：
> 两个元组如下：
> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
> 输出：1
> ```
>
> 
>
> **提示：**
>
> - `n == nums1.length`
> - `n == nums2.length`
> - `n == nums3.length`
> - `n == nums4.length`
> - `1 <= n <= 200`
> - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`

* **解题思路**

  本题视频讲解：[学透哈希表，map使用有技巧！LeetCode：454.四数相加II (opens new window)](https://www.bilibili.com/video/BV1Md4y1Q7Yh)，结合视频在看本题解，事半功倍。

  本题咋眼一看好像和[0015.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)，[0018.四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)差不多，其实差很多。

  **本题是使用哈希法的经典题目，而[0015.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)，[0018.四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)并不合适使用哈希法**，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。

  **而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！**

  如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。

  本题解题步骤：

  1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
  2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
  3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
  4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
  5. 最后返回统计值 count 就可以了

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        int temp;
        // 统计两个数组中的元素之和，同时统计出现的次数，放入map
        for (int i : nums1) {
            for (int j : nums2) {
                temp = i + j;
                map.put(temp, map.getOrDefault(temp, 0) + 1);
            }
        }
        // 统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i : nums3) {
            for (int j : nums4) {
                temp = i + j;
                if (map.containsKey(0 - temp)) {
                    res += map.get(0 - temp);
                }
            }
        }
        return res;
    }
}
```



# 四、字符串

## 4.1 反转字符串

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。
>
> 
>
> **示例 1：**
>
> ```
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]
> ```
>
> **示例 2：**
>
> ```
> 输入：s = ["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]
> ```
>
> 
>
> **提示：**
>
> - `1 <= s.length <= 105`
> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符

```Java
class Solution {
    public void reverseString(char[] s) {
        int start = 0;
        int end = s.length - 1;
        while (start < end) {
            char temp = s[start];
            s[start++] = s[end];
            s[end--] = temp;
        }
    }
}
```



# 五、双指针法

## 5.1 无重复字符的最长子串

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> 
>
> **示例 1:**
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```
>
> 
>
> **提示：**
>
> - `0 <= s.length <= 5 * 104`
> - `s` 由英文字母、数字、符号和空格组成
>
> Related Topics
>
> 哈希表
>
> 字符串
>
> 滑动窗口

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>(s.length());
        int len = 0;
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            if (map.containsKey(s.charAt(right))) {
                // 注意这里是取 s.charAt(right)+1 和 left 中的较大者，因为此时left可能已经超越了前者
                left = Math.max(left, map.get(s.charAt(right)) + 1);
            }
            map.put(s.charAt(right), right);
            len = Math.max(len, right - left + 1);
        }
        return len;
    }
}
```



# 六、二叉树

## 6.1 前中后序遍历

前中后序遍历-递归版

```java
public void preorder(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    // 位置1：result.add(root.val);		前序遍历
    preorder(root.left, result);
    // 位置2：result.add(root.val);		中序遍历
    preorder(root.right, result);
    // 位置3：result.add(root.val);		后序遍历
}
```

前中后序遍历-迭代版

```java
// 前序遍历
// 前序遍历顺序：中-左-右，入栈顺序：中-右-左， 出栈顺序：中-左-右
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.right != null){
                stack.push(node.right);
            }
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
}

// 后续遍历
// 后序遍历顺序：左-右-中， 入栈顺序：中-左-右， 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            // 入栈顺序与前序遍历不同
            if (node.left != null){
                stack.push(node.left);
            }
            if (node.right != null){
                stack.push(node.right);
            }
        }
        // 最后翻转
        Collections.reverse(result);
        return result;
    }
}

// 中序遍历顺序: 左-中-右 入栈顺序： 左-右
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
           if (cur != null){
               stack.push(cur);
               cur = cur.left;
           }else{
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right;
           }
        }
        return result;
    }
}
```



## 6.2 层序遍历

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return Collections.emptyList();
        }
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> list = new ArrayList<>();
            int len = queue.size();
            while (len > 0) {
                TreeNode node = queue.poll();
                list.add(node.val);

                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }    
                len--;
            }
            res.add(list);
        }
        return res;
    }
}
```



## 6.3 翻转二叉树

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)
>
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)
>
> ```
> 输入：root = [2,1,3]
> 输出：[2,3,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 树中节点数目范围在 `[0, 100]` 内
> - `-100 <= Node.val <= 100`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* **解题思路**

  我们下文以前序遍历为例，通过动画来看一下翻转的过程:

  ![翻转二叉树](https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif)

  我们来看一下递归三部曲：

  1. 确定递归函数的参数和返回值

  参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

  返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode*`。

  ```cpp
  TreeNode* invertTree(TreeNode* root)
  ```

  2. 确定终止条件

  当前节点为空的时候，就返回

  ```cpp
  if (root == NULL) return root;
  ```

  3. 确定单层递归的逻辑

  因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。

  ```cpp
  swap(root->left, root->right);
  invertTree(root->left);
  invertTree(root->right);
  ```

```java
// 解法一：递归
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        invertTree(root.left);
        invertTree(root.right);
        swapChildren(root);
        return root;
    }

    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}

// 解法二：迭代
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        ArrayDeque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int len = deque.size();
            while (len-- > 0) {
                TreeNode node = deque.poll();
                swapChildren(node);
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return root;
    }

    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}
```



## 6.4 对称二叉树

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)
>
> ```
> 输入：root = [1,2,2,3,4,4,3]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)
>
> ```
> 输入：root = [1,2,2,null,3,null,3]
> 输出：false
> ```
>
> 
>
> **提示：**
>
> - 树中节点数目在范围 `[1, 1000]` 内
> - `-100 <= Node.val <= 100`
>
> 
>
> **进阶：**你可以运用递归和迭代两种方法解决这个问题吗？
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* **解题思路**

  对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

  那么如果比较呢？

  比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

  ![101. 对称二叉树1](https://img-blog.csdnimg.cn/20210203144624414.png)

  那么遍历的顺序应该是什么样的呢？

  本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

  **正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

  但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。

  其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。

  ## 递归法

  递归三部曲

  1.确定递归函数的参数和返回值

  因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

  返回值自然是bool类型。

  代码如下：

  ```text
  bool compare(TreeNode* left, TreeNode* right)
  ```

  2.确定终止条件

  要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

  节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

  - 左节点为空，右节点不为空，不对称，return false
  - 左不为空，右为空，不对称 return false
  - 左右都为空，对称，返回true

  此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

  - 左右都不为空，比较节点数值，不相同就return false

  此时左右节点不为空，且数值也不相同的情况我们也处理了。

  代码如下：

  ```cpp
  if (left == NULL && right != NULL) return false;
  else if (left != NULL && right == NULL) return false;
  else if (left == NULL && right == NULL) return true;
  else if (left->val != right->val) return false; // 注意这里我没有使用else
  ```

  注意上面最后一种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。

  3.确定单层递归的逻辑

  此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

  - 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
  - 比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
  - 如果左右都对称就返回true ，有一侧不对称就返回false 。

  代码如下：

  ```cpp
  bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
  bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
  bool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）
  return isSame;
  ```

  如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。

  ## 迭代法

  这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。

  这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（**注意这不是层序遍历**）

  ### [#](https://www.programmercarl.com/0101.对称二叉树.html#使用队列)使用队列

  通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：

  ![101.对称二叉树](https://tva1.sinaimg.cn/large/008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif)

```java
// 递归法
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return compare(root.left, root.right);
    }

    private boolean compare(TreeNode left, TreeNode right) {
        if (left == null && right != null) {
            return false;
        }
        else if (left != null && right == null) {
            return false;
        }
        else if (left == null && right == null) {
            return true;
        }
        else if (left.val != right.val) {
            return false;
        }
        // 比较外侧
        boolean compareOutside = compare(left.left, right.right);
        // 比较外侧
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
}

// 迭代法，使用双端队列和普通队列都可
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        Deque<TreeNode> queue = new LinkedList();
        queue.offerFirst(root.left);
        queue.offerLast(root.right);
        while (!queue.isEmpty()) {
            TreeNode left = queue.pollFirst();
            TreeNode right = queue.pollLast();
            if (left == null && right == null) {
                // 注意这里是continue
                continue;
            }
            if (left == null || right == null || left.val != right.val) {
                return false;
            }
            queue.offerFirst(left.left);
            queue.offerLast(right.right);
            queue.offerFirst(left.right);
            queue.offerLast(right.left);
        }
        return true;
    }
}
```



## 6.5 二叉树的最大深度

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。
>
> **示例：**
> 给定二叉树 `[3,9,20,null,null,15,7]`，
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
>
> 返回它的最大深度 3 。
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* **解题思路**

  ## 递归法

  本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

  - 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
  - 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）

  **而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

  这一点其实是很多同学没有想清楚的，很多题解同样没有讲清楚。

  我先用后序遍历（左右中）来计算树的高度。

  1.确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。

  代码如下：

  ```cpp
  int getdepth(treenode* node)
  ```

  2.确定终止条件：如果为空节点的话，就返回0，表示高度为0。

  代码如下：

  ```cpp
  if (node == NULL) return 0;
  ```

  3.确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。

  代码如下：

  ```cpp
  int leftdepth = getdepth(node->left);       // 左
  int rightdepth = getdepth(node->right);     // 右
  int depth = 1 + max(leftdepth, rightdepth); // 中
  return depth;
  ```

  所以整体c++代码如下：

  ```cpp
  class solution {
  public:
      int getdepth(treenode* node) {
          if (node == NULL) return 0;
          int leftdepth = getdepth(node->left);       // 左
          int rightdepth = getdepth(node->right);     // 右
          int depth = 1 + max(leftdepth, rightdepth); // 中
          return depth;
      }
      int maxdepth(treenode* root) {
          return getdepth(root);
      }
  };
  ```

  代码精简之后c++代码如下：

  ```cpp
  class solution {
  public:
      int maxdepth(treenode* root) {
          if (root == null) return 0;
          return 1 + max(maxdepth(root->left), maxdepth(root->right));
      }
  };
  ```

  **精简之后的代码根本看不出是哪种遍历方式，也看不出递归三部曲的步骤，所以如果对二叉树的操作还不熟练，尽量不要直接照着精简代码来学。**

  本题当然也可以使用前序，代码如下：(**充分表现出求深度回溯的过程**)

  ```cpp
  class solution {
  public:
      int result;
      void getdepth(treenode* node, int depth) {
          result = depth > result ? depth : result; // 中
  
          if (node->left == NULL && node->right == NULL) return ;
  
          if (node->left) { // 左
              depth++;    // 深度+1
              getdepth(node->left, depth);
              depth--;    // 回溯，深度-1
          }
          if (node->right) { // 右
              depth++;    // 深度+1
              getdepth(node->right, depth);
              depth--;    // 回溯，深度-1
          }
          return ;
      }
      int maxdepth(treenode* root) {
          result = 0;
          if (root == NULL) return result;
          getdepth(root, 1);
          return result;
      }
  };
  ```

  **可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！**

  注意以上代码是为了把细节体现出来，简化一下代码如下：

  ```cpp
  class solution {
  public:
      int result;
      void getdepth(treenode* node, int depth) {
          result = depth > result ? depth : result; // 中
          if (node->left == NULL && node->right == NULL) return ;
          if (node->left) { // 左
              getdepth(node->left, depth + 1);
          }
          if (node->right) { // 右
              getdepth(node->right, depth + 1);
          }
          return ;
      }
      int maxdepth(treenode* root) {
          result = 0;
          if (root == 0) return result;
          getdepth(root, 1);
          return result;
      }
  };
  ```

  ## [#](https://www.programmercarl.com/0104.二叉树的最大深度.html#迭代法)迭代法

  使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。

  在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：

  ![层序遍历](https://img-blog.csdnimg.cn/20200810193056585.png)

  所以这道题的迭代法就是一道模板题，可以使用二叉树层序遍历的模板来解决的。

  ```java
  // 解法一：递归-后序遍历
  class solution {
      /**
       * 递归法
       */
      public int maxDepth(TreeNode root) {
          if (root == null) {
              return 0;
          }
          int leftDepth = maxDepth(root.left);
          int rightDepth = maxDepth(root.right);
          return Math.max(leftDepth, rightDepth) + 1;
      }
  }
  
  // 解法二：递归-后序遍历
  class Solution {
    /**
     * 递归法(求深度法)
     */
      //定义最大深度
      int maxnum = 0;
  
      public int maxDepth(TreeNode root) {
          ans(root,0);
          return maxnum;
      }
      
      //递归求解最大深度
      void ans(TreeNode tr,int tmp){
          if(tr==null) return;
          tmp++;
          maxnum = maxnum<tmp?tmp:maxnum;
          ans(tr.left,tmp);
          ans(tr.right,tmp);
          tmp--;	// 回溯
      }
  }
  
  // 解法三：迭代法-层序遍历
  class Solution {
      public int maxDepth(TreeNode root) {
          if (root == null) {
              return 0;
          }
          int deep = 0;
          TreeNode cur = root;
          Queue<TreeNode> queue = new LinkedList<>();
          queue.offer(cur);
          while (!queue.isEmpty()) {
              int len = queue.size();
              while (len-- > 0) {
                  cur = queue.poll();
                  if (cur.left != null) {
                      queue.offer(cur.left);
                  }
                  if (cur.right != null) {
                      queue.offer(cur.right);
                  }
              }
              deep += 1;
          }
          return deep;
      }
  }
  ```




## 6.6 二叉树的最小深度

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/dc1b731caa8d80c58bb22811ac88f833499bd9650bedb1f39579c7415b94d91c/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f31322f65785f64657074682e6a7067)](https://camo.githubusercontent.com/dc1b731caa8d80c58bb22811ac88f833499bd9650bedb1f39579c7415b94d91c/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f31322f65785f64657074682e6a7067)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：2
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [2,null,3,null,4,null,5,null,6]
> 输出：5
> ```
>
> **提示：**
>
> - 树中节点数的范围在 `[0, 105]` 内
> - `-1000 <= Node.val <= 1000`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* **解题思路**

  看完了这篇[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)，再来看看如何求最小深度。

  直觉上好像和求最大深度差不多，其实还是差不少的。

  本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。

  - 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
  - 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）

  那么使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，这不过这个最小距离 也同样是最小深度。

  以下讲解中遍历顺序上依然采用后序遍历（因为要比较递归返回之后的结果，本文我也给出前序遍历的写法）。

  本题还有一个误区，在处理节点的过程中，最大深度很容易理解，最小深度就不那么好理解，如图：

  [![111.二叉树的最小深度](https://camo.githubusercontent.com/93b85ef3d6e7a070f3281f4cf8949ec7affb07261311f989848ce2e7167ef5b6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135353830303530332e706e67)](https://camo.githubusercontent.com/93b85ef3d6e7a070f3281f4cf8949ec7affb07261311f989848ce2e7167ef5b6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135353830303530332e706e67)

  这就重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**，注意是**叶子节点**。

  什么是叶子节点，左右孩子都为空的节点才是叶子节点！

  #### [#](https://www.programmercarl.com/0111.二叉树的最小深度.html#递归法)递归法

  来来来，一起递归三部曲：

  1.确定递归函数的参数和返回值

  参数为要传入的二叉树根节点，返回的是int类型的深度。

  代码如下：

  ```c++
  int getDepth(TreeNode* node)
  ```

  2.确定终止条件

  终止条件也是遇到空节点返回0，表示当前节点的高度为0。

  代码如下：

  ```c++
  if (node == NULL) return 0;
  ```

  3.确定单层递归的逻辑

  这块和求最大深度可就不一样了，一些同学可能会写如下代码：

  ```c++
  int leftDepth = getDepth(node->left);
  int rightDepth = getDepth(node->right);
  int result = 1 + min(leftDepth, rightDepth);
  return result;
  ```

  这个代码就犯了此图中的误区：

  [![111.二叉树的最小深度](https://camo.githubusercontent.com/93b85ef3d6e7a070f3281f4cf8949ec7affb07261311f989848ce2e7167ef5b6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135353830303530332e706e67)](https://camo.githubusercontent.com/93b85ef3d6e7a070f3281f4cf8949ec7affb07261311f989848ce2e7167ef5b6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135353830303530332e706e67)

  如果这么求的话，没有左孩子的分支会算为最短深度。

  所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

  反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

  代码如下：

  ```c++
  int leftDepth = getDepth(node->left);           // 左
  int rightDepth = getDepth(node->right);         // 右
                                                  // 中
  // 当一个左子树为空，右不为空，这时并不是最低点
  if (node->left == NULL && node->right != NULL) { 
      return 1 + rightDepth;
  }   
  // 当一个右子树为空，左不为空，这时并不是最低点
  if (node->left != NULL && node->right == NULL) { 
      return 1 + leftDepth;
  }
  int result = 1 + min(leftDepth, rightDepth);
  return result;
  ```

  遍历的顺序为后序（左右中），可以看出：**求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。**

  整体递归代码如下：

  ```c++
  class Solution {
  public:
      int getDepth(TreeNode* node) {
          if (node == NULL) return 0;
          int leftDepth = getDepth(node->left);           // 左
          int rightDepth = getDepth(node->right);         // 右
                                                          // 中
          // 当一个左子树为空，右不为空，这时并不是最低点
          if (node->left == NULL && node->right != NULL) { 
              return 1 + rightDepth;
          }   
          // 当一个右子树为空，左不为空，这时并不是最低点
          if (node->left != NULL && node->right == NULL) { 
              return 1 + leftDepth;
          }
          int result = 1 + min(leftDepth, rightDepth);
          return result;
      }
  
      int minDepth(TreeNode* root) {
          return getDepth(root);
      }
  };
  ```

  精简之后代码如下：

  ```c++
  class Solution {
  public:
      int minDepth(TreeNode* root) {
          if (root == NULL) return 0;
          if (root->left == NULL && root->right != NULL) {
              return 1 + minDepth(root->right);
          }
          if (root->left != NULL && root->right == NULL) {
              return 1 + minDepth(root->left);
          }
          return 1 + min(minDepth(root->left), minDepth(root->right));
      }
  };
  ```

  **精简之后的代码根本看不出是哪种遍历方式，所以依然还要强调一波：如果对二叉树的操作还不熟练，尽量不要直接照着精简代码来学。**

  前序遍历的方式：

  ```c++
  class Solution {
  private:
      int result;
      void getdepth(TreeNode* node, int depth) {
          if (node->left == NULL && node->right == NULL) {
              result = min(depth, result);  
              return;
          }
          // 中 只不过中没有处理的逻辑
          if (node->left) { // 左
              getdepth(node->left, depth + 1);
          }
          if (node->right) { // 右
              getdepth(node->right, depth + 1);
          }
          return ;
      }
  
  public:
      int minDepth(TreeNode* root) {
          if (root == NULL) return 0;
          result = INT_MAX;
          getdepth(root, 1);
          return result;
      }
  };
  ```

**java题解**

```java
// 解法一：递归-后续遍历
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);					// 左
        int right = minDepth(root.right);				// 右
        // 当一个左子树为空，右不为空，这时并不是最低点	    // 中
        if (root.left == null && root.right != null) {
            return 1 + right;
        }
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (root.left != null && root.right == null) {
            return 1 + left;
        }
        int result = 1 + Math.min(left, right);
        return result;
    }
}

// 解法二：迭代法-层序遍历
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList();
        queue.offer(root);
        int minDepth = 0;
        while (!queue.isEmpty()) {
            int len = queue.size();
            ++minDepth;
            while (len-- > 0) {
                TreeNode node = queue.poll();
                if (node.left == null && node.right == null) {
                    return minDepth;
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return minDepth;
    }
}
```



## 6.7 平衡二叉树

> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：
>
> > 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/a94781cc08ce46b019beaeee5b4b42868b313e8a54a8021856717b15ee39021e/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30362f62616c616e63655f312e6a7067)](https://camo.githubusercontent.com/a94781cc08ce46b019beaeee5b4b42868b313e8a54a8021856717b15ee39021e/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30362f62616c616e63655f312e6a7067)
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：true
> ```
>
> **示例 2：**
>
> [![img](https://camo.githubusercontent.com/1f77a98ea8582cf83806c2a380e6be58702c89588d1c7446e59b843e806cca13/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30362f62616c616e63655f322e6a7067)](https://camo.githubusercontent.com/1f77a98ea8582cf83806c2a380e6be58702c89588d1c7446e59b843e806cca13/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30362f62616c616e63655f322e6a7067)
>
> ```
> 输入：root = [1,2,2,3,3,null,null,4,4]
> 输出：false
> ```
>
> **示例 3：**
>
> ```
> 输入：root = []
> 输出：true
> ```
>
> **提示：**
>
> - 树中的节点数在范围 `[0, 5000]` 内
> - `-104 <= Node.val <= 104`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 二叉树

* **解题思路**

  此时大家应该明白了既然要求比较高度，必然是要后序遍历。

  递归三步曲分析：

  1、明确递归函数的参数和返回值

  参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

  那么如何标记左右子树是否差值大于1呢？

  如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。

  所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

  代码如下：

  ```c++
  // -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
  int getHeight(TreeNode* node)
  ```

  2、明确终止条件

  递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0

  代码如下：

  ```c++
  if (node == NULL) {
      return 0;
  }
  ```

  3、明确单层递归的逻辑

  如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

  分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则则返回-1，表示已经不是二叉平衡树了。

  代码如下：

  ```c++
  int leftHeight = getHeight(node->left); // 左
  if (leftHeight == -1) return -1;
  int rightHeight = getHeight(node->right); // 右
  if (rightHeight == -1) return -1;
  
  int result;
  if (abs(leftHeight - rightHeight) > 1) {  // 中
      result = -1;
  } else {
      result = 1 + max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度
  }
  
  return result;
  ```

  代码精简之后如下：

  ```c++
  int leftHeight = getHeight(node->left);
  if (leftHeight == -1) return -1;
  int rightHeight = getHeight(node->right);
  if (rightHeight == -1) return -1;
  return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
  ```

  此时递归的函数就已经写出来了，这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，则返回-1。

  getHeight整体代码如下：

  ```c++
  int getHeight(TreeNode* node) {
      if (node == NULL) {
          return 0;
      }
      int leftHeight = getHeight(node->left);
      if (leftHeight == -1) return -1;
      int rightHeight = getHeight(node->right);
      if (rightHeight == -1) return -1;
      return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
  }
  ```

  最后本题整体递归代码如下：

  ```c++
  class Solution {
  public:
      // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
      int getHeight(TreeNode* node) {
          if (node == NULL) {
              return 0;
          }
          int leftHeight = getHeight(node->left);
          if (leftHeight == -1) return -1;
          int rightHeight = getHeight(node->right);
          if (rightHeight == -1) return -1;
          return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
      }
      bool isBalanced(TreeNode* root) {
          return getHeight(root) == -1 ? false : true;
      }
  };
  ```

**java题解**

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) == -1 ? false : true;
    }

    public int getHeight(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int left = getHeight(node.left);
        if (left == -1) {
            return -1;
        }
        int right = getHeight(node.right);
        if (right == -1) {
            return -1;
        }
        int result;
        if (Math.abs(left - right) > 1) {
            result = -1;
        } else {
            result = 1 + Math.max(left, right);
        }
        return result;
    }
}
```



## 6.8 二叉树的所有路径

> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/93b5d50fec702ccbdda938e59cde857205649987109166344bc127214b6b3f02/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30332f31322f70617468732d747265652e6a7067)](https://camo.githubusercontent.com/93b5d50fec702ccbdda938e59cde857205649987109166344bc127214b6b3f02/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30332f31322f70617468732d747265652e6a7067)
>
> ```
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [1]
> 输出：["1"]
> ```
>
> **提示：**
>
> - 树中节点的数目在范围 `[1, 100]` 内
> - `-100 <= Node.val <= 100`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 字符串
>
> 回溯
>
> 二叉树

* **解题思路**

  这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。

  在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。

  前序遍历以及回溯的过程如图：

  [![257.二叉树的所有路径](https://camo.githubusercontent.com/874f41d965adfe0ef03e0ba9ad81dbed1b074eea229ab8c301ee7b7583639d8a/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230343135313730323434332e706e67)](https://camo.githubusercontent.com/874f41d965adfe0ef03e0ba9ad81dbed1b074eea229ab8c301ee7b7583639d8a/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230343135313730323434332e706e67)

  我们先使用递归的方式，来做前序遍历。**要知道递归和回溯就是一家的，本题也需要回溯。**

  #### [#](https://www.programmercarl.com/0257.二叉树的所有路径.html#递归)递归

  1、递归函数函数参数以及返回值

  要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：

  ```c++
  void traversal(TreeNode* cur, vector<int>& path, vector<string>& result)
  ```

  2、确定递归终止条件

  再写递归的时候都习惯了这么写：

  ```c++
  if (cur == NULL) {
      终止处理逻辑
  }
  ```

  但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。

  **那么什么时候算是找到了叶子节点？** 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。

  所以本题的终止条件是：

  ```c++
  if (cur->left == NULL && cur->right == NULL) {
      终止处理逻辑
  }
  ```

  为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。

  再来看一下终止处理的逻辑。

  这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。

  **那么为什么使用了vector 结构来记录路径呢？** 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。

  可能有的同学问了，我看有些人的代码也没有回溯啊。

  **其实是有回溯的，只不过隐藏在函数调用时的参数赋值里**，下文我还会提到。

  这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：

  ```c++
  if (cur->left == NULL && cur->right == NULL) { // 遇到叶子节点
      string sPath;
      for (int i = 0; i < path.size() - 1; i++) { // 将path里记录的路径转为string格式
          sPath += to_string(path[i]);
          sPath += "->";
      }
      sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点）
      result.push_back(sPath); // 收集一个路径
      return;
  }
  ```

  3、确定单层递归逻辑

  因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。

  ```c++
  path.push_back(cur->val);
  ```

  然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。

  所以递归前要加上判断语句，下面要递归的节点是否为空，如下

  ```c++
  if (cur->left) {
      traversal(cur->left, path, result);
  }
  if (cur->right) {
      traversal(cur->right, path, result);
  }
  ```

  此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。

  那么回溯要怎么回溯呢，一些同学会这么写，如下：

  ```c++
  if (cur->left) {
      traversal(cur->left, path, result);
  }
  if (cur->right) {
      traversal(cur->right, path, result);
  }
  path.pop_back();
  ```

  这个回溯就要很大的问题，我们知道，**回溯和递归是一一对应的，有一个递归，就要有一个回溯**，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。

  **所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！**

  那么代码应该这么写：

  ```c++
  if (cur->left) {
      traversal(cur->left, path, result);
      path.pop_back(); // 回溯
  }
  if (cur->right) {
      traversal(cur->right, path, result);
      path.pop_back(); // 回溯
  }
  ```

  那么本题整体代码如下：

  ```c++
  // 版本一
  class Solution {
  private:
  
      void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {
          path.push_back(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 
          // 这才到了叶子节点
          if (cur->left == NULL && cur->right == NULL) {
              string sPath;
              for (int i = 0; i < path.size() - 1; i++) {
                  sPath += to_string(path[i]);
                  sPath += "->";
              }
              sPath += to_string(path[path.size() - 1]);
              result.push_back(sPath);
              return;
          }
          if (cur->left) { // 左 
              traversal(cur->left, path, result);
              path.pop_back(); // 回溯
          }
          if (cur->right) { // 右
              traversal(cur->right, path, result);
              path.pop_back(); // 回溯
          }
      }
  
  public:
      vector<string> binaryTreePaths(TreeNode* root) {
          vector<string> result;
          vector<int> path;
          if (root == NULL) return result;
          traversal(root, path, result);
          return result;
      }
  };
  ```

  如上的C++代码充分体现了回溯。

  那么如上代码可以精简成如下代码：

  ```c++
  class Solution {
  private:
  
      void traversal(TreeNode* cur, string path, vector<string>& result) {
          path += to_string(cur->val); // 中
          if (cur->left == NULL && cur->right == NULL) {
              result.push_back(path);
              return;
          }
          if (cur->left) traversal(cur->left, path + "->", result); // 左
          if (cur->right) traversal(cur->right, path + "->", result); // 右
      }
  
  public:
      vector<string> binaryTreePaths(TreeNode* root) {
          vector<string> result;
          string path;
          if (root == NULL) return result;
          traversal(root, path, result);
          return result;
  
      }
  };
  ```

  如上代码精简了不少，也隐藏了不少东西。

  注意在函数定义的时候`void traversal(TreeNode* cur, string path, vector<string>& result)` ，定义的是`string path`，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。（这里涉及到C++语法知识）

  那么在如上代码中，**貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在`traversal(cur->left, path + "->", result);`中的 `path + "->"`。** 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了。

  为了把这份精简代码的回溯过程展现出来，大家可以试一试把：

  ```c++
  if (cur->left) traversal(cur->left, path + "->", result); // 左  回溯就隐藏在这里
  ```

  改成如下代码：

  ```c++
  path += "->";
  traversal(cur->left, path, result); // 左
  ```

  即：

  ```c++
  if (cur->left) {
      path += "->";
      traversal(cur->left, path, result); // 左
  }
  if (cur->right) {
      path += "->";
      traversal(cur->right, path, result); // 右
  }
  ```

  此时就没有回溯了，这个代码就是通过不了的了。

  如果想把回溯加上，就要 在上面代码的基础上，加上回溯，就可以AC了。

  ```c++
  if (cur->left) {
      path += "->";
      traversal(cur->left, path, result); // 左
      path.pop_back(); // 回溯 '>'
      path.pop_back(); // 回溯 '-'
  }
  if (cur->right) {
      path += "->";
      traversal(cur->right, path, result); // 右
      path.pop_back(); // 回溯 '>' 
      path.pop_back(); //  回溯 '-' 
  }
  ```

  整体代码如下：

  ```c++
  //版本二
  class Solution {
  private:
      void traversal(TreeNode* cur, string path, vector<string>& result) {
          path += to_string(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中
          if (cur->left == NULL && cur->right == NULL) {
              result.push_back(path);
              return;
          }
          if (cur->left) {
              path += "->";
              traversal(cur->left, path, result); // 左
              path.pop_back(); // 回溯 '>'
              path.pop_back(); // 回溯 '-'
          }
          if (cur->right) {
              path += "->";
              traversal(cur->right, path, result); // 右
              path.pop_back(); // 回溯'>'
              path.pop_back(); // 回溯 '-'
          }
      }
  
  public:
      vector<string> binaryTreePaths(TreeNode* root) {
          vector<string> result;
          string path;
          if (root == NULL) return result;
          traversal(root, path, result);
          return result;
  
      }
  };
  ```

  **大家应该可以感受出来，如果把 `path + "->"`作为函数参数就是可以的，因为并有没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）**

  **综合以上，第二种递归的代码虽然精简但把很多重要的点隐藏在了代码细节里，第一种递归写法虽然代码多一些，但是把每一个逻辑处理都完整的展现了出来了。**

**java题解**

```java
// 解法一：递归
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        List<String> result = new ArrayList<>();
        getPaths(root, path, result);
        return result;
    }

    public void getPaths(TreeNode node, List<Integer> path, List<String> res) {
        path.add(node.val);
        // 递归结束条件
        if (node.left == null && node.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < path.size() - 1; i++) {
                sb.append(path.get(i)).append("->");
            }
            sb.append(path.get(path.size() - 1));
            res.add(sb.toString());
            return;
        }
        if (node.left != null) {
            getPaths(node.left, path, res);
            // 回溯
            path.remove(path.size() - 1);
        }
        if (node.right != null) {
            getPaths(node.right, path, res);
            // 回溯
            path.remove(path.size() - 1);
        }
    }
}

// 解法二：迭代
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 路径和节点同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 找到叶子节点
            if (node.left == null && node.right == null) {
                res.add(path);
            }
            // 右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            // 右子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return res;
    }
}
```



## 6.9 输出二叉树和为目标值的所有路径

**java题解**

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root, int target) {
        List<String> res = new ArrayList<>();
        Stack<Object> stack = new Stack<>();
        stack.push(root);
        stack.push(root.val + "");
        stack.push(root.val);
        while (!stack.isEmpty()) {
            // 总和
            Integer sum = (Integer) stack.pop();
            // 路径
            String path = (String) stack.pop();
            // 节点
            TreeNode node = (TreeNode) stack.pop();
            if (sum == target) {
                res.add(path);
            }
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
                stack.push(sum + node.right.val);
            }
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
                stack.push(sum + node.left.val);
            }
        }
        return res;
    }
}
```



## 6.10 左叶子之和

> 给定二叉树的根节点 `root` ，返回所有左叶子之和。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/44d3e501aacfcf4cc04eba1ed45b804790dca3d95e464c3e5f6bace6c44edb26/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30342f30382f6c65667473756d2d747265652e6a7067)](https://camo.githubusercontent.com/44d3e501aacfcf4cc04eba1ed45b804790dca3d95e464c3e5f6bace6c44edb26/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30342f30382f6c65667473756d2d747265652e6a7067)
>
> ```
> 输入: root = [3,9,20,null,null,15,7] 
> 输出: 24 
> 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
> ```
>
> **示例 2:**
>
> ```
> 输入: root = [1]
> 输出: 0
> ```
>
> **提示:**
>
> - 节点数在 `[1, 1000]` 范围内
> - `-1000 <= Node.val <= 1000`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* **解题思路**

  **递归法**

  递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。

  递归三部曲：

  1、确定递归函数的参数和返回值

  判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int

  使用题目中给出的函数就可以了。

  2、确定终止条件

  如果遍历到空节点，那么左叶子值一定是0

  ```c++
  if (root == NULL) return 0;
  ```

  注意，只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：

  ```c++
  if (root == NULL) return 0;
  if (root->left == NULL && root->right== NULL) return 0; //其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。
  ```

  3、确定单层递归的逻辑

  当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。

  代码如下：

  ```c++
  int leftValue = sumOfLeftLeaves(root->left);    // 左
  if (root->left && !root->left->left && !root->left->right) {
      leftValue = root->left->val;
  }
  int rightValue = sumOfLeftLeaves(root->right);  // 右
  
  int sum = leftValue + rightValue;               // 中
  return sum;
  ```

  整体递归代码如下：

  ```c++
  class Solution {
  public:
      int sumOfLeftLeaves(TreeNode* root) {
          if (root == NULL) return 0;
          if (root->left == NULL && root->right== NULL) return 0;
  
          int leftValue = sumOfLeftLeaves(root->left);    // 左
          if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况
              leftValue = root->left->val;
          }
          int rightValue = sumOfLeftLeaves(root->right);  // 右
  
          int sum = leftValue + rightValue;               // 中
          return sum;
      }
  };
  ```

  以上代码精简之后如下：

  ```c++
  class Solution {
  public:
      int sumOfLeftLeaves(TreeNode* root) {
          if (root == NULL) return 0;
          int leftValue = 0;
          if (root->left != NULL && root->left->left == NULL && root->left->right == NULL) {
              leftValue = root->left->val;
          }
          return leftValue + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
      }
  };
  ```

  精简之后的代码其实看不出来用的是什么遍历方式了，对于算法初学者以上根据第一个版本来学习。

  **[#](https://www.programmercarl.com/0404.左叶子之和.html#迭代法)迭代法**

  本题迭代法使用前中后序都是可以的，只要把左叶子节点统计出来，就可以了，那么参考文章 [二叉树：听说递归能做的，栈也能做！ (opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)和[二叉树：迭代法统一写法 (opens new window)](https://programmercarl.com/二叉树的统一迭代法.html)中的写法，可以写出一个前序遍历的迭代法。

  判断条件都是一样的，代码如下：

  ```c++
  class Solution {
  public:
      int sumOfLeftLeaves(TreeNode* root) {
          stack<TreeNode*> st;
          if (root == NULL) return 0;
          st.push(root);
          int result = 0;
          while (!st.empty()) {
              TreeNode* node = st.top();
              st.pop();
              if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
                  result += node->left->val;
              }
              if (node->right) st.push(node->right);
              if (node->left) st.push(node->left);
          }
          return result;
      }
  };
  ```

**java题解**

```java
// 解法一：递归法-后续遍历
// 递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 0;
        }
        int left = sumOfLeftLeaves(root.left);      // 左
        int right = sumOfLeftLeaves(root.right);    // 右
        // 如果遇到左叶子节点，则当前root节点的左子树的左叶子节点的和就是root.left.val
        if (root.left != null && root.left.left == null && root.left.right == null) {
            left = root.left.val;
        }
        int sum = left + right;                     // 中
        return sum;
    }
}

// 解法二：迭代法-前序遍历
// 迭代法使用前中后序遍历均可，这里使用了前序遍历
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Stack<TreeNode> stack = new Stack();
        int sum = 0;
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node.left != null && node.left.left == null && node.left.right == null) {
                sum += node.left.val;
            }
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
        return sum;
    }
}
```



## 6.11 找树左下角的值

> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。
>
> 假设二叉树中至少有一个节点。
>
> **示例 1:**
>
> [![img](https://camo.githubusercontent.com/c26d5dfe11c6f8330bc8f4479ebed41836c97a5c18e14071754515057e48c793/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f31342f74726565312e6a7067)](https://camo.githubusercontent.com/c26d5dfe11c6f8330bc8f4479ebed41836c97a5c18e14071754515057e48c793/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f31342f74726565312e6a7067)
>
> ```
> 输入: root = [2,1,3]
> 输出: 1
> ```
>
> **示例 2:**
>
> [![img](https://camo.githubusercontent.com/10167128e2e1d5c9796ab4778ea16d90556800104ff23d6694033be91f9ee934/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f31342f74726565322e6a7067)](https://camo.githubusercontent.com/10167128e2e1d5c9796ab4778ea16d90556800104ff23d6694033be91f9ee934/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f31342f74726565322e6a7067)
>
> ```
> 输入: [1,2,3,4,null,5,6,null,null,7]
> 输出: 7
> ```
>
> **提示:**
>
> - 二叉树的节点个数的范围是 `[1,104]`
> - `-231 <= Node.val <= 231 - 1`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* **解题思路**

  **递归**

  咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？

  没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。

  我们来分析一下题目：在树的**最后一行**找到**最左边的值**。

  首先要是最后一行，然后是最左边的值。

  如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。

  如果对二叉树深度和高度还有点疑惑的话，请看：[110.平衡二叉树 (opens new window)](https://programmercarl.com/0110.平衡二叉树.html)。

  所以要找深度最大的叶子节点。

  那么如果找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。

  递归三部曲：

  2、确定递归函数的参数和返回值

  参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。

  本题还需要类里的两个全局变量，maxLen用来记录最大深度，result记录最大深度最左节点的数值。

  代码如下：

  ```c++
  int maxDepth = INT_MIN;   // 全局变量 记录最大深度
  int result;       // 全局变量 最大深度最左节点的数值
  void traversal(TreeNode* root, int depth)
  ```

  2、确定终止条件

  当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。

  代码如下：

  ```c++
  if (root->left == NULL && root->right == NULL) {
      if (depth > maxDepth) {
          maxDepth = depth;           // 更新最大深度
          result = root->val;   // 最大深度最左面的数值
      }
      return;
  }
  ```

  3、确定单层递归的逻辑

  在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：

  ```c++
                      // 中
  if (root->left) {   // 左
      depth++; // 深度加一
      traversal(root->left, depth);
      depth--; // 回溯，深度减一
  }
  if (root->right) { // 右
      depth++; // 深度加一
      traversal(root->right, depth);
      depth--; // 回溯，深度减一
  }
  return;
  ```

  完整代码如下：

  ```c++
  class Solution {
  public:
      int maxDepth = INT_MIN;
      int result;
      void traversal(TreeNode* root, int depth) {
          if (root->left == NULL && root->right == NULL) {
              if (depth > maxDepth) {
                  maxDepth = depth;
                  result = root->val;
              }
              return;
          }
          if (root->left) {
              depth++;
              traversal(root->left, depth);
              depth--; // 回溯
          }
          if (root->right) {
              depth++;
              traversal(root->right, depth);
              depth--; // 回溯
          }
          return;
      }
      int findBottomLeftValue(TreeNode* root) {
          traversal(root, 0);
          return result;
      }
  };
  ```

  当然回溯的地方可以精简，精简代码如下：

  ```c++
  class Solution {
  public:
      int maxDepth = INT_MIN;
      int result;
      void traversal(TreeNode* root, int depth) {
          if (root->left == NULL && root->right == NULL) {
              if (depth > maxDepth) {
                  maxDepth = depth;
                  result = root->val;
              }
              return;
          }
          if (root->left) {
              traversal(root->left, depth + 1); // 隐藏着回溯
          }
          if (root->right) {
              traversal(root->right, depth + 1); // 隐藏着回溯
          }
          return;
      }
      int findBottomLeftValue(TreeNode* root) {
          traversal(root, 0);
          return result;
      }
  };
  ```

  如果对回溯部分精简的代码 不理解的话，可以看这篇[257. 二叉树的所有路径(opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)

  **[#](https://www.programmercarl.com/0513.找树左下角的值.html#迭代法)迭代法**

  本题使用层序遍历再合适不过了，比递归要好理解的多！

  只需要记录最后一行第一个节点的数值就可以了。

  如果对层序遍历不了解，看这篇[二叉树：层序遍历登场！ (opens new window)](https://programmercarl.com/0102.二叉树的层序遍历.html)，这篇里也给出了层序遍历的模板，稍作修改就一过刷了这道题了。

  代码如下：

  ```c++
  class Solution {
  public:
      int findBottomLeftValue(TreeNode* root) {
          queue<TreeNode*> que;
          if (root != NULL) que.push(root);
          int result = 0;
          while (!que.empty()) {
              int size = que.size();
              for (int i = 0; i < size; i++) {
                  TreeNode* node = que.front();
                  que.pop();
                  if (i == 0) result = node->val; // 记录最后一行第一个元素
                  if (node->left) que.push(node->left);
                  if (node->right) que.push(node->right);
              }
          }
          return result;
      }
  };
  ```

**java题解**

```java
// 解法一：递归法-前序遍历
class Solution {
    // 全局变量，用来存储最大深度和最后需要返回的结果值
    int maxDepth = 0;
    int res;

    public int findBottomLeftValue(TreeNode root) {
        travser(root, maxDepth + 1);
        return res;
    }

    private void travser(TreeNode root, int depth) {
        // 遇到叶子节点，判断最大深度，因为保证的是先遍历左子树，所以res一定是最大深度的最左边的节点的值
        if (root.left == null && root.right == null) {
            if (depth > maxDepth) {
                maxDepth = depth;
                res = root.val;    
            }
            return;
        }
        if (root.left != null) {
            travser(root.left, depth + 1);
        }
        if (root.right != null) {
            travser(root.right, depth + 1);
        }
        return;
    }
}


// 解法二-迭代法-层序遍历（自己的解法）：对层序遍历进行了小改造，在每层的遍历中，先遍历右边的节点，再遍历左边的节点，这样，当遍历到最后一个节点时，一定就是最后一层的最左边的节点了
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size();
            while (len-- > 0) {
                TreeNode node = queue.poll();
                // 先遍历右边的节点
                if (node.right != null) {
                    queue.offer(node.right);
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                // 当queue为空时，当前的节点node一定就是最后一行的最左边的节点
                if (queue.isEmpty()) {
                    return node.val;
                }
            }
        }
        return -1;
    }
}

// 解法三：迭代法-层序遍历
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                // 使用res记录每一层最左边的值，遍历完成后，res一定被替换成了最下面一行最左边的节点值了
                if (i == 0) {
                    res = poll.val;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return res;
    }
}
```



## 6.12 路径总和

> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
>
> **叶子节点** 是指没有子节点的节点。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/4dffd04eb9af79fb3fe57b34b060ebea627ef3a963f09a012109411d382fefe9/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d312e6a7067)](https://camo.githubusercontent.com/4dffd04eb9af79fb3fe57b34b060ebea627ef3a963f09a012109411d382fefe9/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d312e6a7067)
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
> 输出：true
> 解释：等于目标和的根节点到叶节点路径如上图所示。
> ```
>
> **示例 2：**
>
> [![img](https://camo.githubusercontent.com/6546eef0e2aa29124b1023c8c0fbaba8edbd287641d9c4e783ced91e096f5920/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d322e6a7067)](https://camo.githubusercontent.com/6546eef0e2aa29124b1023c8c0fbaba8edbd287641d9c4e783ced91e096f5920/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d322e6a7067)
>
> ```
> 输入：root = [1,2,3], targetSum = 5
> 输出：false
> 解释：树中存在两条根节点到叶子节点的路径：
> (1 --> 2): 和为 3
> (1 --> 3): 和为 4
> 不存在 sum = 5 的根节点到叶子节点的路径。
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [], targetSum = 0
> 输出：false
> 解释：由于树是空的，所以不存在根节点到叶子节点的路径。
> ```
>
> **提示：**
>
> - 树中节点的数目在范围 `[0, 5000]` 内
> - `-1000 <= Node.val <= 1000`
> - `-1000 <= targetSum <= 1000`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* ### **解题思路**

  #### 递归

  可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树

  1、确定递归函数的参数和返回类型

  参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。

  再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

  - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
  - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）
  - 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

  而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？

  如图所示：

  [![112.路径总和](https://camo.githubusercontent.com/218e8b14468c8d1eed6f35ae0300f6d491373b7aced7b6dbe21ef9fc5e76554c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032313032303331363035313231362e706e67)](https://camo.githubusercontent.com/218e8b14468c8d1eed6f35ae0300f6d491373b7aced7b6dbe21ef9fc5e76554c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032313032303331363035313231362e706e67)

  图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。

  所以代码如下：

  ```c++
  bool traversal(treenode* cur, int count)   // 注意函数的返回类型
  ```

  2、确定终止条件

  首先计数器如何统计这一条路径的和呢？

  不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。

  如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。

  如果遍历到了叶子节点，count不为0，就是没找到。

  递归终止条件代码如下：

  ```c++
  if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
  if (!cur->left && !cur->right) return false; // 遇到叶子节点而没有找到合适的边，直接返回
  ```

  3、确定单层递归的逻辑

  因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。

  递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。

  代码如下：

  ```c++
  if (cur->left) { // 左 （空节点不遍历）
      // 遇到叶子节点返回true，则直接返回true
      if (traversal(cur->left, count - cur->left->val)) return true; // 注意这里有回溯的逻辑
  }
  if (cur->right) { // 右 （空节点不遍历）
      // 遇到叶子节点返回true，则直接返回true
      if (traversal(cur->right, count - cur->right->val)) return true; // 注意这里有回溯的逻辑
  }
  return false;
  ```

  以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。

  回溯隐藏在`traversal(cur->left, count - cur->left->val)`这里， 因为把`count - cur->left->val` 直接作为参数传进去，函数结束，count的数值没有改变。

  为了把回溯的过程体现出来，可以改为如下代码：

  ```c++
  if (cur->left) { // 左
      count -= cur->left->val; // 递归，处理节点;
      if (traversal(cur->left, count)) return true;
      count += cur->left->val; // 回溯，撤销处理结果
  }
  if (cur->right) { // 右
      count -= cur->right->val;
      if (traversal(cur->right, count)) return true;
      count += cur->right->val;
  }
  return false;
  ```

  整体代码如下：

  ```c++
  class Solution {
  private:
      bool traversal(TreeNode* cur, int count) {
          if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
          if (!cur->left && !cur->right) return false; // 遇到叶子节点直接返回
  
          if (cur->left) { // 左
              count -= cur->left->val; // 递归，处理节点;
              if (traversal(cur->left, count)) return true;
              count += cur->left->val; // 回溯，撤销处理结果
          }
          if (cur->right) { // 右
              count -= cur->right->val; // 递归，处理节点;
              if (traversal(cur->right, count)) return true;
              count += cur->right->val; // 回溯，撤销处理结果
          }
          return false;
      }
  
  public:
      bool hasPathSum(TreeNode* root, int sum) {
          if (root == NULL) return false;
          return traversal(root, sum - root->val);
      }
  };
  ```

  以上代码精简之后如下：

  ```c++
  class solution {
  public:
      bool hasPathSum(TreeNode* root, int sum) {
          if (root == null) return false;
          if (!root->left && !root->right && sum == root->val) {
              return true;
          }
          return haspathsum(root->left, sum - root->val) || haspathsum(root->right, sum - root->val);
      }
  };
  ```

  **是不是发现精简之后的代码，已经完全看不出分析的过程了，所以我们要把题目分析清楚之后，在追求代码精简。** 这一点我已经强调很多次了！

  #### [#](https://www.programmercarl.com/0112.路径总和.html#迭代)迭代

  如果使用栈模拟递归的话，那么如果做回溯呢？

  **此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。**

  c++就我们用pair结构来存放这个栈里的元素。

  定义为：`pair<TreeNode*, int>` pair<节点指针，路径数值>

  这个为栈里的一个元素。

  如下代码是使用栈模拟的前序遍历，如下：（详细注释）

  ```c++
  class solution {
  
  public:
      bool haspathsum(TreeNode* root, int sum) {
          if (root == null) return false;
          // 此时栈里要放的是pair<节点指针，路径数值>
          stack<pair<TreeNode*, int>> st;
          st.push(pair<TreeNode*, int>(root, root->val));
          while (!st.empty()) {
              pair<TreeNode*, int> node = st.top();
              st.pop();
              // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
              if (!node.first->left && !node.first->right && sum == node.second) return true;
  
              // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
              if (node.first->right) {
                  st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
              }
  
              // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
              if (node.first->left) {
                  st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
              }
          }
          return false;
      }
  };
  ```

**java题解**

```java
// 解法一：递归法
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        return traversal(root, targetSum - root.val);
    }

    private boolean traversal(TreeNode node, int count) {
        // 遇到叶子节点，并且计数为0
        if (node.left == null && node.right == null && count == 0) {
            return true;
        }
        // 遇到叶子节点，并且计数不为0
        if (node.left == null && node.right == null) {
            return false;
        }
        if (node.left != null) {
            boolean hasPathSum = traversal(node.left, count - node.left.val);    // 这里 count - node.val 包含回溯处理
            if (hasPathSum) {
                return true;
            }
        }
        if (node.right != null) {
            boolean hasPathSum = traversal(node.right, count - node.right.val);
            if (hasPathSum) {
                return true;
            }
        }
        return false;
    }
}


// 解法二：迭代法-前序遍历
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        Stack<TreeNode> nodeStack = new Stack<>();
        // 除了要维护一个记录节点指针的栈，还需要记录从头结点到该节点的路径的数值总和
        Stack<Integer> sumStack = new Stack<>();
        nodeStack.push(root);
        sumStack.push(root.val);
        while (!nodeStack.isEmpty()) {
            TreeNode node = nodeStack.pop();
            int sum = sumStack.pop();
            if (node.left == null && node.right == null && sum == targetSum) {
                if (sum == targetSum) {
                    return true;
                }
            } 
            if (node.right != null) {
                nodeStack.push(node.right);
                sumStack.push(sum + node.right.val);
            }
            if (node.left != null) {
                nodeStack.push(node.left);
                sumStack.push(sum + node.left.val);
            }
        }
        return false;
    }
}
```



## 6.13 路径总和II

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/d971dcf905c6b49c49b65a7db83795213478f754679e93071d82c55fd5118ddf/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d6969312e6a7067)](https://camo.githubusercontent.com/d971dcf905c6b49c49b65a7db83795213478f754679e93071d82c55fd5118ddf/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d6969312e6a7067)
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> 输出：[[5,4,11,2],[5,8,4,5]]
> ```
>
> **示例 2：**
>
> [![img](https://camo.githubusercontent.com/6546eef0e2aa29124b1023c8c0fbaba8edbd287641d9c4e783ced91e096f5920/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d322e6a7067)](https://camo.githubusercontent.com/6546eef0e2aa29124b1023c8c0fbaba8edbd287641d9c4e783ced91e096f5920/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30312f31382f7061746873756d322e6a7067)
>
> ```
> 输入：root = [1,2,3], targetSum = 5
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [1,2], targetSum = 0
> 输出：[]
> ```
>
> **提示：**
>
> - 树中节点总数在范围 `[0, 5000]` 内
> - `-1000 <= Node.val <= 1000`
> - `-1000 <= targetSum <= 1000`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 回溯
>
> 二叉树

**java题解**

```java
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        List<Integer> path = new LinkedList<>();
        preoederdfs(root, targetSum, res, path);
        return res;
    }

    private void preoederdfs(TreeNode node, int target, List<List<Integer>> res, List<Integer> path) {
        path.add(node.val);
        // 遇到了叶子节点
        if (node.left == null && node.right == null) {
            if (target - node.val == 0) {
                // 因为这个path中的元素会变动，所以要写成如下形式
                res.add(new ArrayList<>(path));    
            }
            return;
        }

        if (node.left != null) {
            // 这里的 target - node.val 实际上也是回溯，当递归返回时，target的值并不会产生变动 
            preoederdfs(node.left, target - node.val, res, path);
            path.remove(path.size() - 1);   // 回溯
        }
        if (node.right != null) {
            preoederdfs(node.right, target - node.val, res, path);
            path.remove(path.size() - 1);   // 回溯
        }

    }
}
```



## 6.14 从中序与后序遍历序列构造二叉树

> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。
>
> **示例 1:**
>
> [![img](https://camo.githubusercontent.com/058f4dbeabd0078760fdbb9851544356c580a9434ee8b48015f36960a959c73b/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f31392f747265652e6a7067)](https://camo.githubusercontent.com/058f4dbeabd0078760fdbb9851544356c580a9434ee8b48015f36960a959c73b/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f31392f747265652e6a7067)
>
> ```
> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> 输出：[3,9,20,null,null,15,7]
> ```
>
> **示例 2:**
>
> ```
> 输入：inorder = [-1], postorder = [-1]
> 输出：[-1]
> ```
>
> **提示:**
>
> - `1 <= inorder.length <= 3000`
> - `postorder.length == inorder.length`
> - `-3000 <= inorder[i], postorder[i] <= 3000`
> - `inorder` 和 `postorder` 都由 **不同** 的值组成
> - `postorder` 中每一个值都在 `inorder` 中
> - `inorder` **保证**是树的中序遍历
> - `postorder` **保证**是树的后序遍历
>
> Related Topics
>
> 树
>
> 数组
>
> 哈希表
>
> 分治
>
> 二叉树

* ### 解题思路

  首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。

  如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。

  流程如图：

  [![106.从中序与后序遍历序列构造二叉树](https://camo.githubusercontent.com/4ed69d4938c961bfb8b4b53cfafff5a5b3671fc663f120009e4724940974207c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135343234393836302e706e67)](https://camo.githubusercontent.com/4ed69d4938c961bfb8b4b53cfafff5a5b3671fc663f120009e4724940974207c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230333135343234393836302e706e67)

  那么代码应该怎么写呢？

  说到一层一层切割，就应该想到了递归。

  来看一下一共分几步：

  - 第一步：如果数组大小为零的话，说明是空节点了。
  - 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
  - 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
  - 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
  - 第五步：切割后序数组，切成后序左数组和后序右数组
  - 第六步：递归处理左区间和右区间

  不难写出如下代码：（先把框架写出来）

  ```c++
  TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
  
      // 第一步
      if (postorder.size() == 0) return NULL;
  
      // 第二步：后序遍历数组最后一个元素，就是当前的中间节点
      int rootValue = postorder[postorder.size() - 1];
      TreeNode* root = new TreeNode(rootValue);
  
      // 叶子节点
      if (postorder.size() == 1) return root;
  
      // 第三步：找切割点
      int delimiterIndex;
      for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
          if (inorder[delimiterIndex] == rootValue) break;
      }
  
      // 第四步：切割中序数组，得到 中序左数组和中序右数组
      // 第五步：切割后序数组，得到 后序左数组和后序右数组
  
      // 第六步
      root->left = traversal(中序左数组, 后序左数组);
      root->right = traversal(中序右数组, 后序右数组);
  
      return root;
  }
  ```

  **难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。**

  此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。

  **在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！**

  我在[数组：每次遇到二分法，都是一看就会，一写就废 (opens new window)](https://programmercarl.com/0035.搜索插入位置.html)和[数组：这个循环可以转懵很多人！ (opens new window)](https://programmercarl.com/0059.螺旋矩阵II.html)中都强调过循环不变量的重要性，在二分查找以及螺旋矩阵的求解中，坚持循环不变量非常重要，本题也是。

  首先要切割中序数组，为什么先切割中序数组呢？

  切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。

  中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：

  ```c++
  // 找到中序遍历的切割点
  int delimiterIndex;
  for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
      if (inorder[delimiterIndex] == rootValue) break;
  }
  
  // 左闭右开区间：[0, delimiterIndex)
  vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
  // [delimiterIndex + 1, end)
  vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );
  ```

  接下来就要切割后序数组了。

  首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。

  后序数组的切割点怎么找？

  后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。

  **此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。**

  中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。

  代码如下：

  ```c++
  // postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了
  postorder.resize(postorder.size() - 1);
  
  // 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
  vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
  // [leftInorder.size(), end)
  vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());
  ```

  此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。

  接下来可以递归了，代码如下：

  ```c++
  root->left = traversal(leftInorder, leftPostorder);
  root->right = traversal(rightInorder, rightPostorder);
  ```

**java题解**

```java
class Solution {
    // 方便根据数值查找位置
    Map<Integer, Integer> map;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        map = new HashMap<>();
        // 用map保存中序序列的数值对应位置
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        // 统一保持左闭右开
        return findNode(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }

    private TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {
        // 参数里的范围都是左闭右开
        if (inBegin >= inEnd || postBegin >= postEnd) {
            return null;
        }
        // 用后序遍历的最后一个元素构造节点
        TreeNode root = new TreeNode(postorder[postEnd - 1]);
        // 找到后序遍历的最后一个元素在中序遍历中的位置
        int rootIndex = map.get(postorder[postEnd - 1]);
        // 保存中序左子树个数，也即下次递归时后序的左子树的元素个数
        int lenOfLeft = rootIndex - inBegin;
        root.left = findNode(inorder, inBegin, rootIndex,
                             postorder, postBegin, postBegin + lenOfLeft);
        // 注意：1、注意中序数组的开始下标是rootIndex + 1，因为rootIndex是当前的元素
        //      2、后序数组下一次遍历的起始位置是postEnd - 1，因为要排除当前的元素
        root.right = findNode(inorder, rootIndex + 1, inEnd,
                              postorder, postBegin + lenOfLeft, postEnd - 1);
        return root;
    }
}
```



## 6.15 从前序与中序遍历序列构造二叉树

> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。
>
> **示例 1:**
>
> [![img](https://camo.githubusercontent.com/058f4dbeabd0078760fdbb9851544356c580a9434ee8b48015f36960a959c73b/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f31392f747265652e6a7067)](https://camo.githubusercontent.com/058f4dbeabd0078760fdbb9851544356c580a9434ee8b48015f36960a959c73b/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f31392f747265652e6a7067)
>
> ```
> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> 输出: [3,9,20,null,null,15,7]
> ```
>
> **示例 2:**
>
> ```
> 输入: preorder = [-1], inorder = [-1]
> 输出: [-1]
> ```
>
> **提示:**
>
> - `1 <= preorder.length <= 3000`
> - `inorder.length == preorder.length`
> - `-3000 <= preorder[i], inorder[i] <= 3000`
> - `preorder` 和 `inorder` 均 **无重复** 元素
> - `inorder` 均出现在 `preorder`
> - `preorder` **保证** 为二叉树的前序遍历序列
> - `inorder` **保证** 为二叉树的中序遍历序列
>
> Related Topics
>
> 树
>
> 数组
>
> 哈希表
>
> 分治
>
> 二叉树

**java题解**

```java
class Solution {
    // 方便根据数值查找位置
    Map<Integer, Integer> map;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        // 用map保存中序序列的数值对应位置
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        // 统一保持左闭右开
        return findNode(inorder, 0, inorder.length, preorder, 0, preorder.length);
    }

    private TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] preorder, int preBegin, int preEnd) {
        // 参数里的范围都是左闭右开
        if (inBegin >= inEnd || preBegin >= preEnd) {
            return null;
        }
        // 用前序遍历的第一个元素构造节点
        TreeNode root = new TreeNode(preorder[preBegin]);
        // 找到前序遍历的第一个元素在中序遍历中的位置
        int rootIndex = map.get(preorder[preBegin]);
        // 保存中序左子树个数，也即下次递归时前序的左子树的元素个数
        int lenOfLeft = rootIndex - inBegin;
        // 注意前序数组下一次遍历的起始位置是preBegin + 1，因为要排除当前的元素
        root.left = findNode(inorder, inBegin, rootIndex,
                             preorder, preBegin + 1, preBegin + 1 + lenOfLeft);
        // 注意中序数组的开始下标是rootIndex + 1，因为rootIndex是当前的元素
        root.right = findNode(inorder, rootIndex + 1, inEnd,
                              preorder, preBegin + 1 + lenOfLeft, preEnd);
        return root;
    }
}
```



## 6.16 最大二叉树

> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
>
> 1. 创建一个根节点，其值为 `nums` 中的最大值。
> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
>
> 返回 *`nums` 构建的* ***最大二叉树\*** 。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/857c1f7ad3b7c317aa9bb4fe819e1cc8eb2098eb7f4add660a045d6a5b79a294/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f32342f74726565312e6a7067)](https://camo.githubusercontent.com/857c1f7ad3b7c317aa9bb4fe819e1cc8eb2098eb7f4add660a045d6a5b79a294/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f32342f74726565312e6a7067)
>
> ```
> 输入：nums = [3,2,1,6,0,5]
> 输出：[6,3,5,null,2,0,null,null,1]
> 解释：递归调用如下所示：
> - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
>     - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
>         - 空数组，无子节点。
>         - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
>             - 空数组，无子节点。
>             - 只有一个元素，所以子节点是一个值为 1 的节点。
>     - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
>         - 只有一个元素，所以子节点是一个值为 0 的节点。
>         - 空数组，无子节点。
> ```
>
> **示例 2：**
>
> [![img](https://camo.githubusercontent.com/f646e735e229e220ae0d9a79275622deff103adc9f2079aac9d25fb10b854de7/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f32342f74726565322e6a7067)](https://camo.githubusercontent.com/f646e735e229e220ae0d9a79275622deff103adc9f2079aac9d25fb10b854de7/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f32342f74726565322e6a7067)
>
> ```
> 输入：nums = [3,2,1]
> 输出：[3,null,2,null,1]
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 1000`
> - `0 <= nums[i] <= 1000`
> - `nums` 中的所有整数 **互不相同**
>
> Related Topics
>
> 栈
>
> 树
>
> 数组
>
> 分治
>
> 二叉树
>
> 单调栈

**java题解**

```java
// 仿照从中序和前序或中序和后序遍历序列构造二叉树
class Solution {
    // 存储下标，方便查找
    Map<Integer, Integer> map;
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        return findNode(nums, 0, nums.length);
    }

    private TreeNode findNode(int[] nums, int begin, int end) {
        if (begin >= end) {
            return null;
        }

        // 找当前范围内的最大值，构造当前子树的根节点
        int maxNum = Integer.MIN_VALUE;
        for (int i = begin; i < end; i++) {
            maxNum = nums[i] > maxNum ? nums[i] : maxNum;
        }
        TreeNode root = new TreeNode(maxNum);
        int rootIndex = map.get(maxNum);

        root.left = findNode(nums, begin, rootIndex);
        root.right = findNode(nums, rootIndex + 1, end);
        return root;
    }
}
```



## 6.17 合并二叉树

> 给你两棵二叉树： `root1` 和 `root2` 。
>
> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。
>
> 返回合并后的二叉树。
>
> **注意:** 合并过程必须从两个树的根节点开始。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/0ece9ab976dd83dbc7f9754e3d10568cd245416e90491014308d24de8a8dea03/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f30352f6d657267652e6a7067)](https://camo.githubusercontent.com/0ece9ab976dd83dbc7f9754e3d10568cd245416e90491014308d24de8a8dea03/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f30352f6d657267652e6a7067)
>
> ```
> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
> 输出：[3,4,5,5,4,null,7]
> ```
>
> **示例 2：**
>
> ```
> 输入：root1 = [1], root2 = [1,2]
> 输出：[2,2]
> ```
>
> **提示：**
>
> - 两棵树中的节点数目在范围 `[0, 2000]` 内
> - `-104 <= Node.val <= 104`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 广度优先搜索
>
> 二叉树

* ## 解题思路

  ### [#](https://www.programmercarl.com/0617.合并二叉树.html#递归)递归

  二叉树使用递归，就要想使用前中后哪种遍历方式？

  **本题使用哪种遍历都是可以的！**

  我们下面以前序遍历为例。

  动画如下：

  [![617.合并二叉树](https://camo.githubusercontent.com/5ecdcf0b8849263fd5e6fb8d029982da1a935f72aaef4befb2026a49aae3fcab/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676e626a6a713868313667333065323063776e70642e676966)](https://camo.githubusercontent.com/5ecdcf0b8849263fd5e6fb8d029982da1a935f72aaef4befb2026a49aae3fcab/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f30303865476d5a456c7931676e626a6a713868313667333065323063776e70642e676966)

  那么我们来按照递归三部曲来解决：

  1、**确定递归函数的参数和返回值：**

  首先那么要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。

  代码如下：

  ```c++
  TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
  ```

  2、**确定终止条件：**

  因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。

  反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。

  代码如下：

  ```c++
  if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
  if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
  ```

  3、**确定单层递归的逻辑：**

  单层递归的逻辑就比较好些了，这里我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。

  那么单层递归中，就要把两棵树的元素加到一起。

  ```c++
  t1->val += t2->val;
  ```

  接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。

  t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。

  最终t1就是合并之后的根节点。

  代码如下：

  ```c++
  t1->left = mergeTrees(t1->left, t2->left);
  t1->right = mergeTrees(t1->right, t2->right);
  return t1;
  ```

  此时前序遍历，完整代码就写出来了，如下：c++

  ```c++
  class Solution {
  public:
      TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
          if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
          if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
          // 修改了t1的数值和结构
          t1->val += t2->val;                             // 中
          t1->left = mergeTrees(t1->left, t2->left);      // 左
          t1->right = mergeTrees(t1->right, t2->right);   // 右
          return t1;
      }
  };
  ```

  那么中序遍历也是可以的，代码如下：

  ```c++
  class Solution {
  public:
      TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
          if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
          if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
          // 修改了t1的数值和结构
          t1->left = mergeTrees(t1->left, t2->left);      // 左
          t1->val += t2->val;                             // 中
          t1->right = mergeTrees(t1->right, t2->right);   // 右
          return t1;
      }
  };
  ```

  后序遍历依然可以，代码如下：

  ```c++
  class Solution {
  public:
      TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
          if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
          if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
          // 修改了t1的数值和结构
          t1->left = mergeTrees(t1->left, t2->left);      // 左
          t1->right = mergeTrees(t1->right, t2->right);   // 右
          t1->val += t2->val;                             // 中
          return t1;
      }
  };
  ```

  **但是前序遍历是最好理解的，我建议大家用前序遍历来做就OK。**

  如上的方法修改了t1的结构，当然也可以不修改t1和t2的结构，重新定一个树。

  不修改输入树的结构，前序遍历，代码如下：

  ```c++
  class Solution {
  public:
      TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
          if (t1 == NULL) return t2;
          if (t2 == NULL) return t1;
          // 重新定义新的节点，不修改原有两个树的结构
          TreeNode* root = new TreeNode(0);
          root->val = t1->val + t2->val;
          root->left = mergeTrees(t1->left, t2->left);
          root->right = mergeTrees(t1->right, t2->right);
          return root;
      }
  };
  ```

**java题解**

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }

        TreeNode root = new TreeNode(root1.val + root2.val);
        root.left = mergeTrees(root1.left, root2.left);
        root.right = mergeTrees(root1.right, root2.right);
        return root;
    }
}
```



## 6.18 验证二叉搜索树

> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
>
> **有效** 二叉搜索树定义如下：
>
> - 节点的左子树只包含 **小于** 当前节点的数。
> - 节点的右子树只包含 **大于** 当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/41e80973830a02ea13025fd9c784017e4042e626e559e2d4688156910c5b276c/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f30312f74726565312e6a7067)](https://camo.githubusercontent.com/41e80973830a02ea13025fd9c784017e4042e626e559e2d4688156910c5b276c/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f30312f74726565312e6a7067)
>
> ```
> 输入：root = [2,1,3]
> 输出：true
> ```
>
> **示例 2：**
>
> [![img](https://camo.githubusercontent.com/3adeb7a8d2da89b66459ce9a584fcb1603d5a8e331df3c5fa62692cbe2add6a7/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f30312f74726565322e6a7067)](https://camo.githubusercontent.com/3adeb7a8d2da89b66459ce9a584fcb1603d5a8e331df3c5fa62692cbe2add6a7/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31322f30312f74726565322e6a7067)
>
> ```
> 输入：root = [5,1,4,null,null,3,6]
> 输出：false
> 解释：根节点的值是 5 ，但是右子节点的值是 4 。
> ```
>
> **提示：**
>
> - 树中节点数目范围在`[1, 104]` 内
> - `-231 <= Node.val <= 231 - 1`
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 二叉搜索树
>
> 二叉树

* ### 解题思路

  有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。**

  #### [#](https://www.programmercarl.com/0098.验证二叉搜索树.html#递归法)递归法

  可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：

  ```c++
  vector<int> vec;
  void traversal(TreeNode* root) {
      if (root == NULL) return;
      traversal(root->left);
      vec.push_back(root->val); // 将二叉搜索树转换为有序数组
      traversal(root->right);
  }
  ```

  然后只要比较一下，这个数组是否是有序的，**注意二叉搜索树中不能有重复元素**。

  ```c++
  traversal(root);
  for (int i = 1; i < vec.size(); i++) {
      // 注意要小于等于，搜索树里不能有相同元素
      if (vec[i] <= vec[i - 1]) return false;
  }
  return true;
  ```

  整体代码如下：

  ```c++
  class Solution {
  private:
      vector<int> vec;
      void traversal(TreeNode* root) {
          if (root == NULL) return;
          traversal(root->left);
          vec.push_back(root->val); // 将二叉搜索树转换为有序数组
          traversal(root->right);
      }
  public:
      bool isValidBST(TreeNode* root) {
          vec.clear(); // 不加这句在leetcode上也可以过，但最好加上
          traversal(root);
          for (int i = 1; i < vec.size(); i++) {
              // 注意要小于等于，搜索树里不能有相同元素
              if (vec[i] <= vec[i - 1]) return false;
          }
          return true;
      }
  };
  ```

  以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。

  这道题目比较容易陷入两个陷阱：

  - 陷阱1

  **不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**。

  写出了类似这样的代码：

  ```c++
  if (root->val > root->left->val && root->val < root->right->val) {
      return true;
  } else {
      return false;
  }
  ```

  **我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点**。所以以上代码的判断逻辑是错误的。

  例如： [10,5,15,null,null,6,20] 这个case：

  [![二叉搜索树](https://camo.githubusercontent.com/8779d89f6ecf1a67e552240e2d9b1b1b016cb481371264da0a02d5709519a0ef/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303831323139313530313431392e706e67)](https://camo.githubusercontent.com/8779d89f6ecf1a67e552240e2d9b1b1b016cb481371264da0a02d5709519a0ef/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303831323139313530313431392e706e67)

  节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！

  - 陷阱2

  样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。

  此时可以初始化比较元素为longlong的最小值。

  问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。

  了解这些陷阱之后我们来看一下代码应该怎么写：

  递归三部曲：

  - 确定递归函数，返回值以及参数

  要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。

  注意递归函数要有bool类型的返回值， 我们在[二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)](https://programmercarl.com/0112.路径总和.html)中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。

  其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。

  代码如下：

  ```c++
  long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
  bool isValidBST(TreeNode* root)
  ```

  - 确定终止条件

  如果是空节点 是不是二叉搜索树呢？

  是的，二叉搜索树也可以为空！

  代码如下：

  ```c++
  if (root == NULL) return true;
  ```

  - 确定单层递归的逻辑

  中序遍历，一直更新maxVal，一旦发现maxVal >= root->val，就返回false，注意元素相同时候也要返回false。

  代码如下：

  ```c++
  bool left = isValidBST(root->left);         // 左
  
  // 中序遍历，验证遍历的元素是不是从小到大
  if (maxVal < root->val) maxVal = root->val; // 中
  else return false;
  
  bool right = isValidBST(root->right);       // 右
  return left && right;
  ```

  整体代码如下：

  ```c++
  class Solution {
  public:
      long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
      bool isValidBST(TreeNode* root) {
          if (root == NULL) return true;
  
          bool left = isValidBST(root->left);
          // 中序遍历，验证遍历的元素是不是从小到大
          if (maxVal < root->val) maxVal = root->val;
          else return false;
          bool right = isValidBST(root->right);
  
          return left && right;
      }
  };
  ```

  以上代码是因为后台数据有int最小值测试用例，所以都把maxVal改成了longlong最小值。

  如果测试数据中有 longlong的最小值，怎么办？

  不可能在初始化一个更小的值了吧。 建议避免 初始化最小值，如下方法取到最左面节点的数值来比较。

  代码如下：

  ```c++
  class Solution {
  public:
      TreeNode* pre = NULL; // 用来记录前一个节点
      bool isValidBST(TreeNode* root) {
          if (root == NULL) return true;
          bool left = isValidBST(root->left);
  
          if (pre != NULL && pre->val >= root->val) return false;
          pre = root; // 记录前一个节点
  
          bool right = isValidBST(root->right);
          return left && right;
      }
  };
  ```

  最后这份代码看上去整洁一些，思路也清晰。

**java题解**

```java
// 解法一：递归法-中序遍历
// 总体思路：中序遍历时，观察节点元素是否是严格递增
class Solution {
    // 用来记录前一个节点
    TreeNode pre = null; 
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        boolean left = isValidBST(root.left);       // 左

        // 若前一个节点的值大于等于当前的根节点，就不是一颗二叉搜索树
        if (pre != null && pre.val >= root.val) {
            return false;
        }
        pre = root;                                 // 中

        boolean right = isValidBST(root.right);     // 右
        return left && right;
    }
}

// 解法一：迭代法-中序遍历
// 中序遍历时，观察节点元素是否是严格递增
class Solution {
    public boolean isValidBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        // 记录前一个节点
        TreeNode pre = null;
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;                         // 左
            } else {
                // 中，处理
                cur = stack.pop();
                if (pre != null && pre.val >= cur.val) {
                    return false;
                }
                pre = cur;                               

                cur = cur.right;                         // 右
            }
        }
        return true;
    }
}
```



## 6.19 二叉搜索树的最小绝对差

> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
>
> 差值是一个正数，其数值等于两值之差的绝对值。
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/3a8f6d85b4aeb1930b610b80c7b478d17223e87ef6d11ee264d58e2f52d8c09d/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f30352f627374312e6a7067)](https://camo.githubusercontent.com/3a8f6d85b4aeb1930b610b80c7b478d17223e87ef6d11ee264d58e2f52d8c09d/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f30352f627374312e6a7067)
>
> ```c++
> 输入：root = [4,2,6,1,3]
> 输出：1
> ```
>
> **示例 2：**
>
> [![img](https://camo.githubusercontent.com/e04ab79d87d411de1053ddfb1fd1b72fc465f41e4c30d0416f8d5c81ac936827/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f30352f627374322e6a7067)](https://camo.githubusercontent.com/e04ab79d87d411de1053ddfb1fd1b72fc465f41e4c30d0416f8d5c81ac936827/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30322f30352f627374322e6a7067)
>
> ```c++
> 输入：root = [1,0,48,null,null,12,49]
> 输出：1
> ```
>
> **提示：**
>
> - 树中节点的数目范围是 `[2, 104]`
> - `0 <= Node.val <= 105`

* ### 解题思路

  题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。

  **注意是二叉搜索树**，二叉搜索树可是有序的。

  遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。

  #### [#](https://www.programmercarl.com/0530.二叉搜索树的最小绝对差.html#递归)递归

  那么二叉搜索树采用中序遍历，其实就是一个有序数组。

  **在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。**

  最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。

  代码如下：

  ```c++
  class Solution {
  private:
  vector<int> vec;
  void traversal(TreeNode* root) {
      if (root == NULL) return;
      traversal(root->left);
      vec.push_back(root->val); // 将二叉搜索树转换为有序数组
      traversal(root->right);
  }
  public:
      int getMinimumDifference(TreeNode* root) {
          vec.clear();
          traversal(root);
          if (vec.size() < 2) return 0;
          int result = INT_MAX;
          for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
              result = min(result, vec[i] - vec[i-1]);
          }
          return result;
      }
  };
  ```

  以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。

  需要用一个pre节点记录一下cur节点的前一个节点。

  如图：

  [![530.二叉搜索树的最小绝对差](https://camo.githubusercontent.com/931af534c98dc189f90dc5bf4de923540e7b3f287c90cba33cad854f5653f815/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230343135333234373435382e706e67)](https://camo.githubusercontent.com/931af534c98dc189f90dc5bf4de923540e7b3f287c90cba33cad854f5653f815/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230343135333234373435382e706e67)

  一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。

  代码如下：

  ```c++
  class Solution {
  private:
  int result = INT_MAX;
  TreeNode* pre = NULL;
  void traversal(TreeNode* cur) {
      if (cur == NULL) return;
      traversal(cur->left);   // 左
      if (pre != NULL){       // 中
          result = min(result, cur->val - pre->val);
      }
      pre = cur; // 记录前一个
      traversal(cur->right);  // 右
  }
  public:
      int getMinimumDifference(TreeNode* root) {
          traversal(root);
          return result;
      }
  };
  ```

**java题解**

```java
// 解法一：迭代-中序遍历
class Solution {
    TreeNode pre = null;
    int res = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        traverse(root);
        return res;
    }

    private void traverse(TreeNode node) {
        if (node == null) {
            return;
        }
        traverse(node.left);
        if (pre != null) {
            res = Math.min(res, node.val - pre.val);
        }
        pre = node;
        traverse(node.right);
    }
}

// 解法二：迭代法
class Solution {
    public int getMinimumDifference(TreeNode root) {
        int res = Integer.MAX_VALUE;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {	// 指针来访问节点，访问到最底层
                stack.push(cur);	// 将访问的节点放进栈
                cur = cur.left;		// 左
            } else {
                cur = stack.pop();
                if (pre != null) {	// 中
                    res = Math.min(res, cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right;	// 右
            }
        }
        return res;
    }
}
```

**[#](https://www.programmercarl.com/0530.二叉搜索树的最小绝对差.html#总结)总结**

**遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。**

同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。

后面我将继续介绍一系列利用二叉搜索树特性的题目。



## 6.20 二叉搜索树中的众数

> 给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。
>
> 如果树中有不止一个众数，可以按 **任意顺序** 返回。
>
> 假定 BST 满足如下定义：
>
> - 结点左子树中所含节点的值 **小于等于** 当前节点的值
> - 结点右子树中所含节点的值 **大于等于** 当前节点的值
> - 左子树和右子树都是二叉搜索树
>
> **示例 1：**
>
> [![img](https://camo.githubusercontent.com/de71934e07d6a60f4f2f5a396ae9305c596494721580c4da8fc7bb2074c5cd5c/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30332f31312f6d6f64652d747265652e6a7067)](https://camo.githubusercontent.com/de71934e07d6a60f4f2f5a396ae9305c596494721580c4da8fc7bb2074c5cd5c/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032312f30332f31312f6d6f64652d747265652e6a7067)
>
> ```
> 输入：root = [1,null,2,2]
> 输出：[2]
> ```
>
> **示例 2：**
>
> ```
> 输入：root = [0]
> 输出：[0]
> ```
>
> **提示：**
>
> - 树中节点的数目在范围 `[1, 104]` 内
> - `-105 <= Node.val <= 105`
>
> **进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 二叉搜索树
>
> 二叉树

* ### 解题思路

  **既然是搜索树，它中序遍历就是有序的**。

  如图：

  [![501.二叉搜索树中的众数1](https://camo.githubusercontent.com/32563c71076f9d813b5457c456e182e95d5811626d93fde042e7d20d99a145d6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230343135323735383838392e706e67)](https://camo.githubusercontent.com/32563c71076f9d813b5457c456e182e95d5811626d93fde042e7d20d99a145d6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303230343135323735383838392e706e67)

  中序遍历代码如下：

  ```c++
  void searchBST(TreeNode* cur) {
      if (cur == NULL) return ;
      searchBST(cur->left);       // 左
      （处理节点）                // 中
      searchBST(cur->right);      // 右
      return ;
  }
  ```

  遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。

  关键是在有序数组上的话，好搞，在树上怎么搞呢？

  这就考察对树的操作了。

  在[二叉树：搜索树的最小绝对差 (opens new window)](https://programmercarl.com/0530.二叉搜索树的最小绝对差.html)中我们就使用了pre指针和cur指针的技巧，这次又用上了。

  弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。

  而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。

  代码如下：

  ```c++
  if (pre == NULL) { // 第一个节点
      count = 1; // 频率为1
  } else if (pre->val == cur->val) { // 与前一个节点数值相同
      count++;
  } else { // 与前一个节点数值不同
      count = 1;
  }
  pre = cur; // 更新上一个节点
  ```

  此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？

  应该是先遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）

  这种方式遍历了两遍数组。

  那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。

  但这里其实只需要遍历一次就可以找到所有的众数。

  那么如何只遍历一遍呢？

  如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：

  ```c++
  if (count == maxCount) { // 如果和最大值相同，放进result中
      result.push_back(cur->val);
  }
  ```

  是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。

  所以下面要做如下操作：

  频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。

  ```c++
  if (count > maxCount) { // 如果计数大于最大值
      maxCount = count;   // 更新最大频率
      result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
      result.push_back(cur->val);
  }
  ```

  关键代码都讲完了，完整代码如下：（**只需要遍历一遍二叉搜索树，就求出了众数的集合**）

  ```c++
  class Solution {
  private:
      int maxCount = 0; // 最大频率
      int count = 0; // 统计频率
      TreeNode* pre = NULL;
      vector<int> result;
      void searchBST(TreeNode* cur) {
          if (cur == NULL) return ;
  
          searchBST(cur->left);       // 左
                                      // 中
          if (pre == NULL) { // 第一个节点
              count = 1;
          } else if (pre->val == cur->val) { // 与前一个节点数值相同
              count++;
          } else { // 与前一个节点数值不同
              count = 1;
          }
          pre = cur; // 更新上一个节点
  
          if (count == maxCount) { // 如果和最大值相同，放进result中
              result.push_back(cur->val);
          }
  
          if (count > maxCount) { // 如果计数大于最大值频率
              maxCount = count;   // 更新最大频率
              result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
              result.push_back(cur->val);
          }
  
          searchBST(cur->right);      // 右
          return ;
      }
  
  public:
      vector<int> findMode(TreeNode* root) {
          count = 0;
          maxCount = 0;
          TreeNode* pre = NULL; // 记录前一个节点
          result.clear();
  
          searchBST(root);
          return result;
      }
  };
  ```

**java题解**

```java
// 解法一：递归-中序遍历
class Solution {
    TreeNode pre;
    int maxCount;
    int count;
    List<Integer> res;

    public int[] findMode(TreeNode root) {
        pre = null;
        maxCount = 0;
        count = 0;
        res = new ArrayList<>();
        findMaxCountEle(root);
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }

    private void findMaxCountEle(TreeNode node) {
        if (node == null) {
            return;
        }

        findMaxCountEle(node.left);

        // 计数
        if (pre == null || node.val != pre.val) {
            count = 1;
        } else {
            count++;
        }
        // 更新结果以及maxCount
        if (count > maxCount) {
            res.clear();
            maxCount = count;
            res.add(node.val);
        } else if (count == maxCount) {
            res.add(node.val);
        }
        pre = node;

        findMaxCountEle(node.right);
    }
}

// 解法二：迭代-中序遍历
class Solution {
    TreeNode pre;
    int maxCount;
    int count;
    List<Integer> res;

    public int[] findMode(TreeNode root) {
        pre = null;
        maxCount = 0;
        count = 0;
        res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop();

                if (pre == null || cur.val != pre.val) {
                    count = 1;
                } else {
                    ++count;
                }
                if (count > maxCount) {
                    res.clear();
                    maxCount = count;
                    res.add(cur.val);
                } else if (count == maxCount) {
                    res.add(cur.val);
                }
                pre = cur;

                cur = cur.right;
            }
        }
        return res.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```



## 6.21 二叉树的最近公共祖先

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
>
> ```
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
> 输出：3
> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
>
> ```
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
> 输出：5
> 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
> ```
>
> **示例 3：**
>
> ```
> 输入：root = [1,2], p = 1, q = 2
> 输出：1
> ```
>
> 
>
> **提示：**
>
> - 树中节点数目在范围 `[2, 105]` 内。
> - `-109 <= Node.val <= 109`
> - 所有 `Node.val` `互不相同` 。
> - `p != q`
> - `p` 和 `q` 均存在于给定的二叉树中。
>
> Related Topics
>
> 树
>
> 深度优先搜索
>
> 二叉树

* **解题思路**

  遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。

  那么二叉树如何可以自底向上查找呢？

  回溯啊，二叉树回溯的过程就是从低到上。

  后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。

  接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。

  **首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。** 即情况一：

  ![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173502.png)

  判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。

  那么有录友可能疑惑，会不会左子树 遇到q 返回，右子树也遇到q返回，这样并没有找到 q 和p的最近祖先。

  这么想的录友，要审题了，题目强调：**二叉树节点数值是不重复的，而且一定存在 q 和 p**。

  **但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。** 情况二：

  ![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173530.png)

  其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。

  因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本省就是 公共祖先的情况。

  这一点是很多录友容易忽略的，在下面的代码讲解中，可以在去体会。

  递归三部曲：

  1、确定递归函数返回值以及参数

  需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。

  但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。

  代码如下：

  ```cpp
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
  ```

  2、确定终止条件

  遇到空的话，然后然后空，因为树都是空了，所以返回空。

  那么我们来说一说，如果 root == q，或者 root == p，说明找到 q p ，则将其返回，这个返回值，后面在中节点的处理过程中会用到，那么中节点处理逻辑，后下面讲解。

  代码如下：

  ```cpp
  if (root == q || root == p || root == NULL) return root;
  ```

  3、确定单层递归逻辑

  值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。

  我们在[二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)](https://programmercarl.com/0112.路径总和.html)中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！

  如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

  搜索一条边的写法：

  ```cpp
  if (递归函数(root->left)) return ;
  
  if (递归函数(root->right)) return ;
  ```

  搜索整个树写法：

  ```cpp
  left = 递归函数(root->left);  // 左
  right = 递归函数(root->right); // 右
  left与right的逻辑处理;         // 中 
  ```

  看出区别了没？

  **在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

  那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。

  如图：

  ![236.二叉树的最近公共祖先](https://img-blog.csdnimg.cn/2021020415105872.png)

  就像图中一样直接返回7，多美滋滋。

  但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。

  因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。

  ```cpp
  left = 递归函数(root->left);  // 左
  right = 递归函数(root->right); // 右
  left与right的逻辑处理;         // 中 
  ```

  所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。

  那么先用left和right接住左子树和右子树的返回值，代码如下：

  ```cpp
  TreeNode* left = lowestCommonAncestor(root->left, p, q);
  TreeNode* right = lowestCommonAncestor(root->right, p, q);
  ```

  **如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解**

  **如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然**。

  这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？

  如图：

  ![236.二叉树的最近公共祖先1](https://img-blog.csdnimg.cn/20210204151125844.png)

  图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！

  这里点也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。

  那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空。

  代码如下：

  ```cpp
  if (left == NULL && right != NULL) return right;
  else if (left != NULL && right == NULL) return left;
  else  { //  (left == NULL && right == NULL)
      return NULL;
  }
  ```

  那么寻找最小公共祖先，完整流程图如下：

  ![236.二叉树的最近公共祖先2](https://img-blog.csdnimg.cn/202102041512582.png)

  **从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！**

  整体代码如下：

  ```cpp
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          if (root == q || root == p || root == NULL) return root;
          TreeNode* left = lowestCommonAncestor(root->left, p, q);
          TreeNode* right = lowestCommonAncestor(root->right, p, q);
          if (left != NULL && right != NULL) return root;
  
          if (left == NULL && right != NULL) return right;
          else if (left != NULL && right == NULL) return left;
          else  { //  (left == NULL && right == NULL)
              return NULL;
          }
  
      }
  };
  ```

  稍加精简，代码如下：

  ```cpp
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          if (root == q || root == p || root == NULL) return root;
          TreeNode* left = lowestCommonAncestor(root->left, p, q);
          TreeNode* right = lowestCommonAncestor(root->right, p, q);
          if (left != NULL && right != NULL) return root;
          if (left == NULL) return right;
          return left;
      }
  };
  ```

**java题解**

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }

        // 后序遍历
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left == null && right == null) {    // 若未找到节点 p 或 q
            return null;
        } else if (left == null && right != null) { // 若找到一个节点
            return right;
        } else if (left != null && right == null) { // 若找到一个节点
            return left;
        } else {        // 若找到两个节点
            return root;
        }
    }
}
```







# 八、动态规划

## 8.1 斐波那契数

> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给定 `n` ，请计算 `F(n)` 。
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3
> ```
>
> **提示：**
>
> - `0 <= n <= 30`
>
> Related Topics
>
> 递归
>
> 记忆化搜索
>
> 数学
>
> 动态规划

- **解题思路**

  动规五部曲：

  这里我们要用一个一维dp数组来保存递归的结果

  1、确定dp数组以及下标的含义

  dp[i]的定义为：第i个数的斐波那契数值是dp[i]

  2、确定递推公式

  为什么这是一道非常简单的入门题目呢？

  **因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

  3、dp数组如何初始化

  **题目中把如何初始化也直接给我们了，如下：**

  ```
  dp[0] = 0;
  dp[1] = 1;
  ```

  4、确定遍历顺序

  从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5、举例推导dp数组

  按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

  0 1 1 2 3 5 8 13 21 34 55

  如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

```
class Solution {
    public int fib(int n) {
        // 非压缩状态版本
        if (n <= 1) {
            return n == 0 ? 0 : 1;
        }
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];

        // 压缩状态版本
        if (n <= 1) {
            return n;
        }
        int a = 0, b = 1, c = 0;
        for (int i = 1; i < n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```



## 8.2 最大子数组和

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。
>
> **示例 1：**
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [5,4,-1,7,8]
> 输出：23
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
>
> **进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。
>
> Related Topics
>
> 数组
>
> 分治
>
> 动态规划

- **解题思路**

  **关键 1：理解题意**

  题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。

  题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。

  **关键 2：如何定义子问题（如何定义状态）**

  **设计状态思路**：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。

  > 友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，

  我们 **不知道和最大的连续子数组一定会选哪一个数**，那么我们可以求出 **所有** 经过输入数组的某一个数的连续子数组的最大和。

  例如，示例 1 输入数组是 `[-2,1,-3,4,-1,2,1,-5,4]` ，我们可以求出以下子问题：

  - 子问题 1：经过 −2 的连续子数组的最大和是多少；
  - 子问题 2：经过 1 的连续子数组的最大和是多少；
  - 子问题 3：经过 −3 的连续子数组的最大和是多少；
  - 子问题 4：经过 4 的连续子数组的最大和是多少；
  - 子问题 5：经过 −1 的连续子数组的最大和是多少；
  - 子问题 6：经过 2 的连续子数组的最大和是多少；
  - 子问题 7：经过 1 的连续子数组的最大和是多少；
  - 子问题 8：经过 −5 的连续子数组的最大和是多少；
  - 子问题 9：经过 4 的连续子数组的最大和是多少。

  一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 **子问题的描述还有不确定的地方**（**这件事情叫做「有后效性」**，我们在本文的最后会讲解什么是「无后效性」）。

  例如「子问题 3」：经过 −3 的连续子数组的最大和是多少。

  「经过 −3 的连续子数组」我们任意举出几个：

  - `[-2,1,-3,4]` ，−3 是这个连续子数组的第 3 个元素；
  - `[1,-3,4,-1]` ，−3 是这个连续子数组的第 2 个元素；
  - ……

  我们不确定的是：**−3 是连续子数组的第几个元素**。那么我们就把 −3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：

  - 子问题 1：以 −2 **结尾的**连续子数组的最大和是多少；
  - 子问题 2：以 1 结尾的连续子数组的最大和是多少；
  - 子问题 3：以 −3 结尾的连续子数组的最大和是多少；
  - 子问题 4：以 4 结尾的连续子数组的最大和是多少；
  - 子问题 5：以 −1 结尾的连续子数组的最大和是多少；
  - 子问题 6：以 2 结尾的连续子数组的最大和是多少；
  - 子问题 7：以 1 结尾的连续子数组的最大和是多少；
  - 子问题 8：以 −5 结尾的连续子数组的最大和是多少；
  - 子问题 9：以 4 结尾的连续子数组的最大和是多少。

  我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：

  - 子问题 1：以 −2 **结尾的**连续子数组的最大和是多少；

  以 −2 **结尾的**连续子数组是 `[-2]`，因此最大和就是 −2。

  - 子问题 2：以 1 结尾的连续子数组的最大和是多少；

  以 1 结尾的连续子数组有 `[-2,1]` 和 `[1]` ，其中 **`[-2,1]` 就是在「子问题 1」的后面加上 1 得到**。−2+1=−1<1 ，因此「子问题 2」 的答案是 1。

  大家发现了吗，如果编号为 `i` 的子问题的结果是负数或者 0 ，那么编号为 `i + 1` 的子问题就可以把编号为 `i` 的子问题的结果舍弃掉（这里 `i` 为整数，最小值为 `1` ，最大值为 `8`），这是因为：

  - 一个数 `a` 加上负数的结果比 `a` 更小；
  - 一个数 `a` 加上 0 的结果不会比 `a` 更大；
  - 而子问题的定义必须以一个数结尾，因此如果子问题 `i` 的结果是负数或者 0，那么子问题 `i + 1` 的答案就是以 `nums[i]` 结尾的那个数。

  > 因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。

  接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。

  #### 定义状态（定义子问题）

  `dp[i]`：表示以 `nums[i]` **结尾** 的 **连续** 子数组的最大和。

  **说明**：「结尾」和「连续」是关键字。

  #### 状态转移方程（描述子问题之间的联系）

  根据状态的定义，由于 `nums[i]` 一定会被选取，并且以 `nums[i]` 结尾的连续子数组与以 `nums[i - 1]` 结尾的连续子数组只相差一个元素 `nums[i]` 。

  假设数组 `nums` 的值全都严格大于 0，那么一定有 `dp[i] = dp[i - 1] + nums[i]`。

  可是 `dp[i - 1]` 有可能是负数，于是分类讨论：

  - 如果 `dp[i - 1] > 0`，那么可以把 `nums[i]` 直接接在 `dp[i - 1]` 表示的那个数组的后面，得到和更大的连续子数组；
  - 如果 `dp[i - 1] <= 0`，那么 `nums[i]` 加上前面的数 `dp[i - 1]` 以后值不会变大。于是 `dp[i]` 「另起炉灶」，此时单独的一个 `nums[i]` 的值，就是 `dp[i]`。

  以上两种情况的最大值就是 `dp[i]` 的值，写出如下状态转移方程：

  *d**p*[*i*]={*d**p*[*i*−1]+*n**u**m**s*[*i*],*n**u**m**s*[*i*],*i**f**d**p*[*i*−1]>0*i**f**d**p*[*i*−1]≤0

  记为「状态转移方程 1」。

  状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：

  *d**p*[*i*]=max{*n**u**m**s*[*i*],*d**p*[*i*−1]+*n**u**m**s*[*i*]}

  记为「状态转移方程 2」。

  > 友情提示：求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。

  #### 思考初始值

  `dp[0]` 根据定义，只有 1 个数，一定以 `nums[0]` 结尾，因此 `dp[0] = nums[0]`。

  #### 思考输出

  **注意**：

  - 这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**；
  - 这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**；
  - 这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**。

  > 重要的事情说三遍，有时候写东西写得多了，怕读者看不到重点，所以会想方设法进行强调，一句话翻来覆去反复说。我以前和一个在新东方当英语老师的朋友交流过，这样的效果最好。大家可以理解为职业病，我们更多是想要照顾到新手朋友们。大佬要是觉得我讲得啰嗦了，还请忽略。
  >
  > 简单的动态规划问题，很有可能问的问题就可以设计成为子问题，复杂的动态规划问题就没有那么容易看出子问题应该如何设计了，这需要一定的解决问题的经验。

  这个问题的输出是把所有的 `dp[0]`、`dp[1]`、……、`dp[n - 1]` 都看一遍，取最大值。 同样的情况也适用于「力扣」第 300 题：「最长上升子序列」（以后我们有空，再把这道题拿出来再讲一遍，超级超级重要的一道动态规划问题）。

  #### 可以优化空间吗

  根据「状态转移方程」，`dp[i]` 的值只和 `dp[i - 1]` 有关，因此可以使用「滚动变量」的方式将代码进行优化。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //            // 解法一，定义dp[]，空间复杂度为O(n)
        //            if (nums.length == 0) {
        //                return 0;
        //            }
        //            int res = nums[0];
        //            int[] dp = new int[nums.length];
        //            dp[0] = nums[0];
        //            for (int i = 1; i < nums.length; i++) {
        //                dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        //                res = Math.max(res, dp[i]);
        //            }
        //            return res;

        // 解法二
        // 因为dp[i]的递推公式只与前一个值有关，所以可以用一个变量代替dp数组，空间复杂度为O(1)
        int res = nums[0];
        int pre = nums[0];
        for (int i = 1; i < nums.length; i++) {
            pre = Math.max(pre + nums[i], nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}
```



## 8.3 买卖股票的最佳时机

> 动规五部曲分析如下：
>
> 1、确定dp数组（dp table）以及下标的含义
>
> dp[i]\[0] 表示第i天持有股票所得最多现金 ，**这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？**
>
> 其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。
>
> dp[i]\[1] 表示第i天不持有股票所得最多现金
>
> **注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**
>
> 很多同学把“持有”和“买入”没分区分清楚。
>
> 在下面递推公式分析中，我会进一步讲解。
>
> 2、确定递推公式
>
> 如果第i天持有股票即dp[i]\[0]， 那么可以由两个状态推出来
>
> - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1]\[0]
> - 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
>
> 那么dp[i]\[0]应该选所得现金最大的，所以dp[i]\[0] = max(dp[i - 1]\[0], -prices[i]);
>
> 如果第i天不持有股票即dp[i]\[1]， 也可以由两个状态推出来
>
> - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1]\[1]
> - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1]\[0]
>
> 同样dp[i]\[1]取最大的，dp[i]\[1] = max(dp[i - 1]\[1], prices[i] + dp[i - 1]\[0]);
>
> 这样递归公式我们就分析完了
>
> 3、dp数组如何初始化
>
> 由递推公式 dp[i]\[0] = max(dp[i - 1]\[0], -prices[i]); 和 dp[i]\[1] = max(dp[i - 1]\[1], prices[i] + dp[i - 1]\[0]);可以看出
>
> 其基础都是要从dp[0]\[0]和dp[0]\[1]推导出来。
>
> 那么dp[0]\[0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0]\[0] -= prices[0];
>
> dp[0]\[1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0]\[1] = 0;
>
> 4、确定遍历顺序
>
> 从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。
>
> 5、举例推导dp数组
>
> 以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：
>
> [![121.买卖股票的最佳时机](https://camo.githubusercontent.com/78e2645aa4c75347a77c601bfa862419cda9f0494622bfcfc693ac4a6b044c19/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303232343232353634323436352e706e67)](https://camo.githubusercontent.com/78e2645aa4c75347a77c601bfa862419cda9f0494622bfcfc693ac4a6b044c19/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303232343232353634323436352e706e67)
>
> dp[5]\[1]就是最终结果。
>
> 为什么不是dp[5]\[0]呢？
>
> **因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
}
```



## 8.4 买卖股票的最佳时机 II

> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
> 返回 *你能获得的 **最大** 利润* 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>      总利润为 4 + 3 = 7 。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      总利润为 4 。
> ```
>
> **示例 3：**
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
> ```
>
> 
>
> **提示：**
>
> - `1 <= prices.length <= 3 * 104`
> - `0 <= prices[i] <= 104`
>
> Related Topics
>
> 贪心
>
> 数组
>
> 动态规划

* **解题思路**

  本题和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）

  **在动规五部曲中，这个区别主要是体现在递推公式上，其他都和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)一样一样的**。

  所以我们重点讲一讲递推公式。

  这里重申一下dp数组的含义：

  - dp[i]\[0] 表示第i天持有股票所得现金。
  - dp[i]\[1] 表示第i天不持有股票所得最多现金

  如果第i天持有股票即dp[i]\[0]， 那么可以由两个状态推出来

  - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1]\[0]
  - 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1]\[1] - prices[i]

  **注意这里和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况**。

  在[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i]\[0]一定就是 -prices[i]。

  而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。

  那么第i天持有股票即dp[i]\[0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1]\[1] - prices[i]。

  在来看看如果第i天不持有股票即dp[i]\[1]的情况， 依然可以由两个状态推出来

  - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1]\[1]
  - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1]\[0]

  **注意这里和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);    // 唯一和买卖股票的最佳时机不同的地方
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
}
```



## 8.5 买卖股票的最佳时机 III

> 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。
>
> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> 
>
> **示例 1:**
>
> ```
> 输入：prices = [3,3,5,0,0,3,1,4]
> 输出：6
> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> ```
>
> **示例 3：**
>
> ```
> 输入：prices = [7,6,4,3,1] 
> 输出：0 
> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
> ```
>
> **示例 4：**
>
> ```
> 输入：prices = [1]
> 输出：0
> ```
>
> 
>
> **提示：**
>
> - `1 <= prices.length <= 105`
> - `0 <= prices[i] <= 105`
>
> Related Topics
>
> 数组
>
> 动态规划

* **解题思路**

  关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

  接来下我用动态规划五部曲详细分析一下：

  1. 确定dp数组以及下标的含义

  一天一共就有五个状态，

  1. 没有操作
  2. 第一次买入
  3. 第一次卖出
  4. 第二次买入
  5. 第二次卖出

  dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

  1. 确定递推公式

  需要注意：dp[i]\[1]，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

  达到dp[i][1]状态，有两个具体操作：

  - 操作一：第i天买入股票了，那么dp[i]\[1] = dp[i-1]\[0] - prices[i]
  - 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i]\[1] = dp[i - 1]\[1]

  那么dp[i][1]究竟选 dp[i-1]\[0] - prices[i]，还是dp[i - 1]\[1]呢？

  一定是选最大的，所以 dp[i]\[1] = max(dp[i-1]\[0] - prices[i], dp[i - 1]\[1]);

  同理dp[i]\[2]也有两个操作：

  - 操作一：第i天卖出股票了，那么dp[i]\[2] = dp[i - 1]\[1] + prices[i]
  - 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i]\[2] = dp[i - 1]\[2]

  所以dp[i]\[2] = max(dp[i - 1]\[1] + prices[i], dp[i - 1]\[2])

  同理可推出剩下状态部分：

  dp[i]\[3] = max(dp[i - 1]\[3], dp[i - 1]\[2] - prices[i]);

  dp[i]\[4] = max(dp[i - 1]\[4], dp[i - 1]\[3] + prices[i]);

  1. dp数组如何初始化

  第0天没有操作，这个最容易想到，就是0，即：dp[0]\[0] = 0;

  第0天做第一次买入的操作，dp[0]\[1] = -prices[0];

  第0天做第一次卖出的操作，这个初始值应该是多少呢？

  首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，

  从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。

  所以dp[0]\[2] = 0;

  第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

  第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

  所以第二次买入操作，初始化为：dp[0]\[3] = -prices[0];

  同理第二次卖出初始化dp[0]\[4] = 0;

  1. 确定遍历顺序

  从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。

  1. 举例推导dp数组

  以输入[1,2,3,4,5]为例

  ![123.买卖股票的最佳时机III](https://img-blog.csdnimg.cn/20201228181724295.png)

  大家可以看到红色框为最后两次卖出的状态。

  现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。

  所以最终最大利润是dp[4]\[4]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][5];
        dp[0][0] = 0;
        dp[0][1] = dp[0][3]= -prices[0];
        dp[0][2] = dp[0][4] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[len-1][4];
    }
}
```







# 合并区间

> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
>
> 
>
> **示例 1：**
>
> ```
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```
>
> **示例 2：**
>
> ```
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```
>
> 
>
> **提示：**
>
> - `1 <= intervals.length <= 104`
> - `intervals[i].length == 2`
> - `0 <= starti <= endi <= 104`
>
> Related Topics
>
> 数组
>
> 排序

* **解题思路**

  如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：

  ![](https://img-blog.csdnimg.cn/img_convert/1839458bc45af95cd2d91bb46ec5ab39.png)

  算法

  我们用数组 merged 存储最终的答案。

  首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：

  如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；

  否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。


```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(o -> o[0]));
        List<int[]> merged = new ArrayList<>(intervals.length);
        for (int i = 0; i < intervals.length; i++) {
            int L = intervals[i][0];
            int R = intervals[i][1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < L) {
                merged.add(new int[]{L, R});
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(R, merged.get(merged.size() - 1)[1]);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```

