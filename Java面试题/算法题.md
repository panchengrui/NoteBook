# 一、数组

## 1.1 二分查找

> 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
>
> **示例 1:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1
> ```
>
> 
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

* **注意**

  **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

  二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

  写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

* **解题思路**

  第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：

  ![704.二分查找](https://img-blog.csdnimg.cn/20210311153055723.jpg)

```java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;
        if (nums == null || length == 0
            // 避免当target小于nums中的最小数或者大于最大数时多次循环
            || target < nums[0] || target > nums[length - 1]) {
            return -1;
        }
        int left = 0;
        // (1)
        int right = length - 1;
        // (2) 注意这里写得是 <= , 当然也可以写成 < , 不过(1)处要改为right=length，（3）处要改为right=mid
        while (left <= right) {
            int mid = left + ((right - left) / 2);
            if (target == nums[mid]) {
                return mid;
            }
            else if (target > nums[mid]) {
                left = mid + 1;
            } else {
                // （3）
                right = mid - 1;
            }
        }
        return -1;
    }
}
```



## 1.2 移除元素

> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> 
>
> **说明:**
>
> 为什么返回数值是整数，但输出的答案是数组呢?
>
> 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> ```
> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
> int len = removeElement(nums, val);
> 
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>  print(nums[i]);
> }
> ```
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2]
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3]
> 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
> ```
>
> 
>
> **提示：**
>
> - `0 <= nums.length <= 100`
> - `0 <= nums[i] <= 50`
> - `0 <= val <= 100`
>
> Related Topics：数组、双指针

* **解题思路**

  使用快慢指针的方法，快指针是循环的变量，每次循环将指针向前移动，

  慢指针是新数组的下标

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新 新数组下标的位置

  ![](https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif#pic_center)

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (val != nums[fast]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
}
```



## 1.3 有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
>
> 
>
> **示例 1：**
>
> ```
>输入：nums = [-4,-1,0,3,10]
> 输出：[0,1,9,16,100]
> 解释：平方后，数组变为 [16,1,0,9,100]
> 排序后，数组变为 [0,1,9,16,100]
> ```
> 
> **示例 2：**
>
> ```
>输入：nums = [-7,-3,2,3,11]
> 输出：[4,9,9,49,121]
> ```
> 
> 
>
> **提示：**
>
> - `1 <= nums.length <= 104`
>- `-104 <= nums[i] <= 104`
> - `nums` 已按 **非递减顺序** 排序
> 
> 
>
> **进阶：**
>
> - 请你设计时间复杂度为 `O(n)` 的算法解决本问题
>
> Related Topics：数组、双指针、排序

* **解题思路**

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

  如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

  如动画所示：

  ![](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif#pic_center)

  

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] newArr = new int[nums.length];
        int left = 0, right = nums.length - 1, newArrIndex = right;
        while (left <= right) {
            int lNum = nums[left] * nums[left];
            int rNum = nums[right] * nums[right];
            if (lNum > rNum) {
                newArr[newArrIndex--] = lNum;
                ++left;
            } else {
                newArr[newArrIndex--] = rNum;
                --right;
            }
        }
        return newArr;
    }
}
```



## 1.4 长度最小的子数组

> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**
>
> 找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：target = 7, nums = [2,3,1,2,4,3]
> 输出：2
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> ```
>
> **示例 2：**
>
> ```
> 输入：target = 4, nums = [1,4,4]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：target = 11, nums = [1,1,1,1,1,1,1,1]
> 输出：0
> ```
>
> 
>
> **提示：**
>
> - `1 <= target <= 109`
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 105`
>
> 
>
> **进阶：**
>
> - 如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。
>
> Related Topics：数组、滑动窗口

* **解题思路**

  滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

  在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

  那么滑动窗口如何用一个for循环来完成这个操作呢。

  首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

  如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？

  此时难免再次陷入 暴力解法的怪圈。

  所以 只用一个for循环，那么这个**循环的索引，一定是表示 滑动窗口的终止位置**。

  那么问题来了， 滑动窗口的起始位置如何移动呢？

  这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

  ![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

  最后找到 4，3 是最短距离。

  其实从动画中可以发现**滑动窗口也可以理解为双指针法的一种**！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？
  - 如何移动窗口的起始位置？
  - 如何移动窗口的结束位置？

  **窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。**

  **窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。**

  **窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。**

  解题的关键在于 窗口的起始位置如何移动，如图所示：

  ![leetcode_209](https://img-blog.csdnimg.cn/20210312160441942.png)

  可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minLen = Integer.MAX_VALUE;
        // 外层循环中的索引控制的是滑动窗口的结束位置
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                minLen = Math.min(minLen, right - left + 1);
                // 这里体现出滑动窗口的精髓之处，不断变更窗口的起始位置
                sum -= nums[left++];
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```



# 二、链表

## 2.1 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)
>
> ```
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [], val = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [7,7,7,7], val = 7
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 列表中的节点数目在范围 `[0, 104]` 内
> - `1 <= Node.val <= 50`
> - `0 <= val <= 50`

* **解题思路**

  **可以设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

  来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。

  ![203_链表删除元素6](https://img-blog.csdnimg.cn/20210316095619221.png)

  这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。

  这样是不是就可以使用和移除链表其他节点的方式统一了呢？

  来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。

  最后呢在题目中，return 头结点的时候，别忘了 `return dummyNode->next;`， 这才是新的头结点

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        ListNode cur = head;
        while (cur != null) {
            if (cur.val == val) {
                pre.next = cur.next;
            } else {
                // 注意这里的 pre = cur 要写在else分支中，而不是和下面的 cur = cur.next放在一起，如示例3，存在多个需要删除的值连续的情况，pre可以理解为新链表的元素下标，如果当前值和目标值不相等时，也就是该值应该保留，才应该将pre向后移一位，否则应该保留当前的下标位置
                pre = cur;
            }
            cur = cur.next;
        }
        // 应注意这里返回的是dummy.next，而不是head
        return dummy.next;
    }
}
```



## 2.2 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)
>
> ```
> 输入：head = [1,2]
> 输出：[2,1]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>
> 
>
> **进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

* **解题思路**

  我们拿有示例中的链表来举例，如动画所示：（纠正：动画应该是先移动pre，在移动cur）

  ![img](https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

  首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

  然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

  为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

  接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

  最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

  递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 解法一：双指针
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;

        // 解法二：递归
        return reverse(null, head);
    }

    private ListNode reverse(ListNode pre, ListNode cur) {
        if (cur == null) {
            return pre;
        }
        ListNode temp = cur.next;
        cur.next = pre;
        /*pre = cur;
            cur = temp;
            return reverse(pre, cur);*/
        // 等同于上面的代码
        return reverse(cur, temp);
    }
}
```



## 2.3 两两交换链表中的节点

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1]
> 输出：[1]
> ```
>
> 
>
> **提示：**
>
> - 链表中节点的数目在范围 `[0, 100]` 内
> - `0 <= Node.val <= 100`

* **解题思路**

  建议使用虚拟头结点，这样会方便很多，要不然每次针对头结点（没有前一个指针指向头结点），还要单独处理。

  对虚拟头结点的操作，还不熟悉的话，可以看这篇[链表：听说用虚拟头节点会方便很多？ (opens new window)](https://programmercarl.com/0203.移除链表元素.html)。

  接下来就是交换相邻两个元素了，**此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序**

  初始时，cur指向虚拟头结点，然后进行如下三步：

  ![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

  操作之后，链表如下：

  ![24.两两交换链表中的节点2](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png)

  看这个可能就更直观一些了：

  ![24.两两交换链表中的节点3](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode pre = dummy;
        while (pre.next != null && pre.next.next != null) {
            // 缓存next
            ListNode temp = head.next.next;
            pre.next = head.next;
            head.next.next = head;
            // 将head的next接上缓存的temp
            head.next = temp;
            // 步进一位
            pre = head;
            head = head.next;
        }
        return dummy.next;
    }
}
```



## 2.4 删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
>
> 
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [1], n = 1
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：head = [1,2], n = 1
> 输出：[1]
> ```
>
> 
>
> **提示：**
>
> - 链表中结点的数目为 `sz`
> - `1 <= sz <= 30`
> - `0 <= Node.val <= 100`
> - `1 <= n <= sz`
>
> 
>
> **进阶：**你能尝试使用一趟扫描实现吗？
>
> Related Topics：链表、双指针

* **解题思路**

  双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

  思路是这样的，但要注意一些细节。

  分为如下几步：

  - 首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑，如果虚拟头结点不清楚，可以看这篇： [链表：听说用虚拟头节点会方便很多？(opens new window)](https://programmercarl.com/0203.移除链表元素.html)
  - 定义fast指针和slow指针，初始值为虚拟头结点，如图：

  ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png)

  - fast首先走**n + 1**步 ，**为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点**（方便做删除操作），如图： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png)
  - fast和slow同时移动，直到fast指向末尾，如题： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png)
  - 删除slow指向的下一个节点，如图： ![img](https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png)

```Java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1, head);
        ListNode slow = dummy, fast = dummy;
        for (int i = 0; i < n + 1; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



# 三、哈希表

## 3.1 有效的字母异位词

> 给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。
>
> **注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。
>
> 
>
> **示例 1:**
>
> ```
> 输入: s = "anagram", t = "nagaram"
> 输出: true
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "rat", t = "car"
> 输出: false
> ```
>
> 
>
> **提示:**
>
> - `1 <= s.length, t.length <= 5 * 104`
> - `s` 和 `t` 仅包含小写字母
>
> 
>
> **进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
>
> Related Topics：哈希表、字符串

* **解题思路**

  **数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。

  如果对哈希表的理论基础关于数组，set，map不了解的话可以看这篇：[关于哈希表，你该了解这些！(opens new window)](https://programmercarl.com/哈希表理论基础.html)

  需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。

  为了方便举例，判断一下字符串s= "aee", t = "eae"。

  操作动画如下：

  ![242.有效的字母异位词](https://tva1.sinaimg.cn/large/008eGmZEly1govxyg83bng30ds09ob29.gif)

  定义一个数组叫做record用来上记录字符串s里字符出现的次数。

  需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

  再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

  那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

  那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

  最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] record = new int[26];

        for (int i = 0; i < s.length(); i++) {
            record[s.charAt(i) - 'a']++;
        }

        for (int i = 0; i < t.length(); i++) {
            record[t.charAt(i) - 'a']--;
        }
        
        for (int count: record) {
            if (count != 0) {
                return false;
            }
        }
        return true;
    }
}
```



## 3.2 两个数组的交集

> 给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2,2,1], nums2 = [2,2]
> 输出：[2]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出：[9,4]
> 解释：[4,9] 也是可通过的
> ```
>
> 
>
> **提示：**
>
> - `1 <= nums1.length, nums2.length <= 1000`
> - `0 <= nums1[i], nums2[i] <= 1000`

* **解题思路**

  **如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

  此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：

  - std::set
  - std::multiset
  - std::unordered_set

  std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

  思路如图所示：

  ![set哈希法](https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png)

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        // 遍历数组1
        for (int i : nums1) {
            set1.add(i);
        }
        // 遍历数组2的过程中判断哈希表中是否存在该元素
        for (int i : nums2) {
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }
        // 将结果转为数组
        return resSet.stream().mapToInt(x -> x).toArray();
    }
}
```



## 3.3 快乐数

> 编写一个算法来判断一个数 `n` 是不是快乐数。
>
> **「快乐数」** 定义为：
>
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
>
> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：n = 19
> 输出：true
> 解释：
> 12 + 92 = 82
> 82 + 22 = 68
> 62 + 82 = 100
> 12 + 02 + 02 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 2
> 输出：false
> ```
>
> 
>
> **提示：**
>
> - `1 <= n <= 231 - 1`

* **解题思路**

  这道题目看上去貌似一道数学问题，其实并不是！

  题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

  正如：[关于哈希表，你该了解这些！ (opens new window)](https://programmercarl.com/哈希表理论基础.html)中所说，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

  所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。

  判断sum是否重复出现就可以使用unordered_set。

  **还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。**

```Java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```



## 3.4 四数相加

> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：
>
> - `0 <= i, j, k, l < n`
> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
>
> 
>
> **示例 1：**
>
> ```
> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 输出：2
> 解释：
> 两个元组如下：
> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
> ```
>
> **示例 2：**
>
> ```
> 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
> 输出：1
> ```
>
> 
>
> **提示：**
>
> - `n == nums1.length`
> - `n == nums2.length`
> - `n == nums3.length`
> - `n == nums4.length`
> - `1 <= n <= 200`
> - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`

* **解题思路**

  本题视频讲解：[学透哈希表，map使用有技巧！LeetCode：454.四数相加II (opens new window)](https://www.bilibili.com/video/BV1Md4y1Q7Yh)，结合视频在看本题解，事半功倍。

  本题咋眼一看好像和[0015.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)，[0018.四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)差不多，其实差很多。

  **本题是使用哈希法的经典题目，而[0015.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)，[0018.四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)并不合适使用哈希法**，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。

  **而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！**

  如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。

  本题解题步骤：

  1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
  2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
  3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
  4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
  5. 最后返回统计值 count 就可以了

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        int temp;
        // 统计两个数组中的元素之和，同时统计出现的次数，放入map
        for (int i : nums1) {
            for (int j : nums2) {
                temp = i + j;
                map.put(temp, map.getOrDefault(temp, 0) + 1);
            }
        }
        // 统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i : nums3) {
            for (int j : nums4) {
                temp = i + j;
                if (map.containsKey(0 - temp)) {
                    res += map.get(0 - temp);
                }
            }
        }
        return res;
    }
}
```



# 四、字符串

## 4.1 反转字符串

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。
>
> 
>
> **示例 1：**
>
> ```
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]
> ```
>
> **示例 2：**
>
> ```
> 输入：s = ["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]
> ```
>
> 
>
> **提示：**
>
> - `1 <= s.length <= 105`
> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符

```Java
class Solution {
    public void reverseString(char[] s) {
        int start = 0;
        int end = s.length - 1;
        while (start < end) {
            char temp = s[start];
            s[start++] = s[end];
            s[end--] = temp;
        }
    }
}
```



# 五、双指针法

## 5.1 无重复字符的最长子串

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> 
>
> **示例 1:**
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> ```
>
> **示例 2:**
>
> ```
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> ```
>
> **示例 3:**
>
> ```
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> ```
>
> 
>
> **提示：**
>
> - `0 <= s.length <= 5 * 104`
> - `s` 由英文字母、数字、符号和空格组成
>
> Related Topics
>
> 哈希表
>
> 字符串
>
> 滑动窗口

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>(s.length());
        int len = 0;
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            if (map.containsKey(s.charAt(right))) {
                // 注意这里是取 s.charAt(right)+1 和 left 中的较大者，因为此时left可能已经超越了前者
                left = Math.max(left, map.get(s.charAt(right)) + 1);
            }
            map.put(s.charAt(right), right);
            len = Math.max(len, right - left + 1);
        }
        return len;
    }
}
```





# 八、动态规划

## 8.1 斐波那契数

> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> ```
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> ```
>
> 给定 `n` ，请计算 `F(n)` 。
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：2
> 解释：F(3) = F(2) + F(1) = 1 + 1 = 2
> ```
>
> **示例 3：**
>
> ```
> 输入：n = 4
> 输出：3
> 解释：F(4) = F(3) + F(2) = 2 + 1 = 3
> ```
>
> **提示：**
>
> - `0 <= n <= 30`
>
> Related Topics
>
> 递归
>
> 记忆化搜索
>
> 数学
>
> 动态规划

- **解题思路**

  动规五部曲：

  这里我们要用一个一维dp数组来保存递归的结果

  1、确定dp数组以及下标的含义

  dp[i]的定义为：第i个数的斐波那契数值是dp[i]

  2、确定递推公式

  为什么这是一道非常简单的入门题目呢？

  **因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];**

  3、dp数组如何初始化

  **题目中把如何初始化也直接给我们了，如下：**

  ```
  dp[0] = 0;
  dp[1] = 1;
  ```

  4、确定遍历顺序

  从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5、举例推导dp数组

  按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

  0 1 1 2 3 5 8 13 21 34 55

  如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

```
class Solution {
    public int fib(int n) {
        // 非压缩状态版本
        if (n <= 1) {
            return n == 0 ? 0 : 1;
        }
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];

        // 压缩状态版本
        if (n <= 1) {
            return n;
        }
        int a = 0, b = 1, c = 0;
        for (int i = 1; i < n; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```

## 8.2 最大子数组和

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。
>
> **示例 1：**
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [5,4,-1,7,8]
> 输出：23
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`
>
> **进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。
>
> Related Topics
>
> 数组
>
> 分治
>
> 动态规划

- **解题思路**

  **关键 1：理解题意**

  题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。

  题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。

  **关键 2：如何定义子问题（如何定义状态）**

  **设计状态思路**：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。

  > 友情提示：上面这句话大家姑且这么一看，脑子里有个印象，没有那么绝对。可能不同的人看会有不同的理解。如果我以后讲解的动态规划的设计思想与这里讲解的「设计状态思路」不一样的，我会再和大家说明。如果讲解有误导的地方，还请大家指出。，

  我们 **不知道和最大的连续子数组一定会选哪一个数**，那么我们可以求出 **所有** 经过输入数组的某一个数的连续子数组的最大和。

  例如，示例 1 输入数组是 `[-2,1,-3,4,-1,2,1,-5,4]` ，我们可以求出以下子问题：

  - 子问题 1：经过 −2 的连续子数组的最大和是多少；
  - 子问题 2：经过 1 的连续子数组的最大和是多少；
  - 子问题 3：经过 −3 的连续子数组的最大和是多少；
  - 子问题 4：经过 4 的连续子数组的最大和是多少；
  - 子问题 5：经过 −1 的连续子数组的最大和是多少；
  - 子问题 6：经过 2 的连续子数组的最大和是多少；
  - 子问题 7：经过 1 的连续子数组的最大和是多少；
  - 子问题 8：经过 −5 的连续子数组的最大和是多少；
  - 子问题 9：经过 4 的连续子数组的最大和是多少。

  一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 **子问题的描述还有不确定的地方**（**这件事情叫做「有后效性」**，我们在本文的最后会讲解什么是「无后效性」）。

  例如「子问题 3」：经过 −3 的连续子数组的最大和是多少。

  「经过 −3 的连续子数组」我们任意举出几个：

  - `[-2,1,-3,4]` ，−3 是这个连续子数组的第 3 个元素；
  - `[1,-3,4,-1]` ，−3 是这个连续子数组的第 2 个元素；
  - ……

  我们不确定的是：**−3 是连续子数组的第几个元素**。那么我们就把 −3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：

  - 子问题 1：以 −2 **结尾的**连续子数组的最大和是多少；
  - 子问题 2：以 1 结尾的连续子数组的最大和是多少；
  - 子问题 3：以 −3 结尾的连续子数组的最大和是多少；
  - 子问题 4：以 4 结尾的连续子数组的最大和是多少；
  - 子问题 5：以 −1 结尾的连续子数组的最大和是多少；
  - 子问题 6：以 2 结尾的连续子数组的最大和是多少；
  - 子问题 7：以 1 结尾的连续子数组的最大和是多少；
  - 子问题 8：以 −5 结尾的连续子数组的最大和是多少；
  - 子问题 9：以 4 结尾的连续子数组的最大和是多少。

  我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：

  - 子问题 1：以 −2 **结尾的**连续子数组的最大和是多少；

  以 −2 **结尾的**连续子数组是 `[-2]`，因此最大和就是 −2。

  - 子问题 2：以 1 结尾的连续子数组的最大和是多少；

  以 1 结尾的连续子数组有 `[-2,1]` 和 `[1]` ，其中 **`[-2,1]` 就是在「子问题 1」的后面加上 1 得到**。−2+1=−1<1 ，因此「子问题 2」 的答案是 1。

  大家发现了吗，如果编号为 `i` 的子问题的结果是负数或者 0 ，那么编号为 `i + 1` 的子问题就可以把编号为 `i` 的子问题的结果舍弃掉（这里 `i` 为整数，最小值为 `1` ，最大值为 `8`），这是因为：

  - 一个数 `a` 加上负数的结果比 `a` 更小；
  - 一个数 `a` 加上 0 的结果不会比 `a` 更大；
  - 而子问题的定义必须以一个数结尾，因此如果子问题 `i` 的结果是负数或者 0，那么子问题 `i + 1` 的答案就是以 `nums[i]` 结尾的那个数。

  > 因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。

  接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。

  #### 定义状态（定义子问题）

  `dp[i]`：表示以 `nums[i]` **结尾** 的 **连续** 子数组的最大和。

  **说明**：「结尾」和「连续」是关键字。

  #### 状态转移方程（描述子问题之间的联系）

  根据状态的定义，由于 `nums[i]` 一定会被选取，并且以 `nums[i]` 结尾的连续子数组与以 `nums[i - 1]` 结尾的连续子数组只相差一个元素 `nums[i]` 。

  假设数组 `nums` 的值全都严格大于 0，那么一定有 `dp[i] = dp[i - 1] + nums[i]`。

  可是 `dp[i - 1]` 有可能是负数，于是分类讨论：

  - 如果 `dp[i - 1] > 0`，那么可以把 `nums[i]` 直接接在 `dp[i - 1]` 表示的那个数组的后面，得到和更大的连续子数组；
  - 如果 `dp[i - 1] <= 0`，那么 `nums[i]` 加上前面的数 `dp[i - 1]` 以后值不会变大。于是 `dp[i]` 「另起炉灶」，此时单独的一个 `nums[i]` 的值，就是 `dp[i]`。

  以上两种情况的最大值就是 `dp[i]` 的值，写出如下状态转移方程：

  *d**p*[*i*]={*d**p*[*i*−1]+*n**u**m**s*[*i*],*n**u**m**s*[*i*],*i**f**d**p*[*i*−1]>0*i**f**d**p*[*i*−1]≤0

  记为「状态转移方程 1」。

  状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：

  *d**p*[*i*]=max{*n**u**m**s*[*i*],*d**p*[*i*−1]+*n**u**m**s*[*i*]}

  记为「状态转移方程 2」。

  > 友情提示：求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。

  #### 思考初始值

  `dp[0]` 根据定义，只有 1 个数，一定以 `nums[0]` 结尾，因此 `dp[0] = nums[0]`。

  #### 思考输出

  **注意**：

  - 这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**；
  - 这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**；
  - 这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**。

  > 重要的事情说三遍，有时候写东西写得多了，怕读者看不到重点，所以会想方设法进行强调，一句话翻来覆去反复说。我以前和一个在新东方当英语老师的朋友交流过，这样的效果最好。大家可以理解为职业病，我们更多是想要照顾到新手朋友们。大佬要是觉得我讲得啰嗦了，还请忽略。
  >
  > 简单的动态规划问题，很有可能问的问题就可以设计成为子问题，复杂的动态规划问题就没有那么容易看出子问题应该如何设计了，这需要一定的解决问题的经验。

  这个问题的输出是把所有的 `dp[0]`、`dp[1]`、……、`dp[n - 1]` 都看一遍，取最大值。 同样的情况也适用于「力扣」第 300 题：「最长上升子序列」（以后我们有空，再把这道题拿出来再讲一遍，超级超级重要的一道动态规划问题）。

  #### 可以优化空间吗

  根据「状态转移方程」，`dp[i]` 的值只和 `dp[i - 1]` 有关，因此可以使用「滚动变量」的方式将代码进行优化。

```
class Solution {
    public int maxSubArray(int[] nums) {
        //            // 解法一，定义dp[]，空间复杂度为O(n)
        //            if (nums.length == 0) {
        //                return 0;
        //            }
        //            int res = nums[0];
        //            int[] dp = new int[nums.length];
        //            dp[0] = nums[0];
        //            for (int i = 1; i < nums.length; i++) {
        //                dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        //                res = Math.max(res, dp[i]);
        //            }
        //            return res;

        // 解法二
        // 因为dp[i]的递推公式只与前一个值有关，所以可以用一个变量代替dp数组，空间复杂度为O(1)
        int res = nums[0];
        int pre = nums[0];
        for (int i = 1; i < nums.length; i++) {
            pre = Math.max(pre + nums[i], nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}
```

## 8.3 买卖股票的最佳时机

> 动规五部曲分析如下：
>
> 1、确定dp数组（dp table）以及下标的含义
>
> dp[i]\[0] 表示第i天持有股票所得最多现金 ，**这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？**
>
> 其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。
>
> dp[i]\[1] 表示第i天不持有股票所得最多现金
>
> **注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**
>
> 很多同学把“持有”和“买入”没分区分清楚。
>
> 在下面递推公式分析中，我会进一步讲解。
>
> 2、确定递推公式
>
> 如果第i天持有股票即dp[i]\[0]， 那么可以由两个状态推出来
>
> - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1]\[0]
> - 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
>
> 那么dp[i]\[0]应该选所得现金最大的，所以dp[i]\[0] = max(dp[i - 1]\[0], -prices[i]);
>
> 如果第i天不持有股票即dp[i]\[1]， 也可以由两个状态推出来
>
> - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1]\[1]
> - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1]\[0]
>
> 同样dp[i]\[1]取最大的，dp[i]\[1] = max(dp[i - 1]\[1], prices[i] + dp[i - 1]\[0]);
>
> 这样递归公式我们就分析完了
>
> 3、dp数组如何初始化
>
> 由递推公式 dp[i]\[0] = max(dp[i - 1]\[0], -prices[i]); 和 dp[i]\[1] = max(dp[i - 1]\[1], prices[i] + dp[i - 1]\[0]);可以看出
>
> 其基础都是要从dp[0]\[0]和dp[0]\[1]推导出来。
>
> 那么dp[0]\[0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0]\[0] -= prices[0];
>
> dp[0]\[1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0]\[1] = 0;
>
> 4、确定遍历顺序
>
> 从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。
>
> 5、举例推导dp数组
>
> 以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：
>
> [![121.买卖股票的最佳时机](https://camo.githubusercontent.com/78e2645aa4c75347a77c601bfa862419cda9f0494622bfcfc693ac4a6b044c19/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303232343232353634323436352e706e67)](https://camo.githubusercontent.com/78e2645aa4c75347a77c601bfa862419cda9f0494622bfcfc693ac4a6b044c19/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303232343232353634323436352e706e67)
>
> dp[5]\[1]就是最终结果。
>
> 为什么不是dp[5]\[0]呢？
>
> **因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
}
```



## 8.4 买卖股票的最佳时机 II

> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
> 返回 *你能获得的 **最大** 利润* 。
>
> 
>
> **示例 1：**
>
> ```
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>      总利润为 4 + 3 = 7 。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      总利润为 4 。
> ```
>
> **示例 3：**
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
> ```
>
> 
>
> **提示：**
>
> - `1 <= prices.length <= 3 * 104`
> - `0 <= prices[i] <= 104`
>
> Related Topics
>
> 贪心
>
> 数组
>
> 动态规划

* **解题思路**

  本题和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）

  **在动规五部曲中，这个区别主要是体现在递推公式上，其他都和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)一样一样的**。

  所以我们重点讲一讲递推公式。

  这里重申一下dp数组的含义：

  - dp[i]\[0] 表示第i天持有股票所得现金。
  - dp[i]\[1] 表示第i天不持有股票所得最多现金

  如果第i天持有股票即dp[i]\[0]， 那么可以由两个状态推出来

  - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1]\[0]
  - 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1]\[1] - prices[i]

  **注意这里和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况**。

  在[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i]\[0]一定就是 -prices[i]。

  而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。

  那么第i天持有股票即dp[i]\[0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1]\[1] - prices[i]。

  在来看看如果第i天不持有股票即dp[i]\[1]的情况， 依然可以由两个状态推出来

  - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1]\[1]
  - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1]\[0]

  **注意这里和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！**

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);    // 唯一和买卖股票的最佳时机不同的地方
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
}
```



## 8.4 买卖股票的最佳时机 III

> 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。
>
> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> 
>
> **示例 1:**
>
> ```
> 输入：prices = [3,3,5,0,0,3,1,4]
> 输出：6
> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>      随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> ```
>
> **示例 3：**
>
> ```
> 输入：prices = [7,6,4,3,1] 
> 输出：0 
> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
> ```
>
> **示例 4：**
>
> ```
> 输入：prices = [1]
> 输出：0
> ```
>
> 
>
> **提示：**
>
> - `1 <= prices.length <= 105`
> - `0 <= prices[i] <= 105`
>
> Related Topics
>
> 数组
>
> 动态规划

* **解题思路**

  关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

  接来下我用动态规划五部曲详细分析一下：

  1. 确定dp数组以及下标的含义

  一天一共就有五个状态，

  1. 没有操作
  2. 第一次买入
  3. 第一次卖出
  4. 第二次买入
  5. 第二次卖出

  dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

  1. 确定递推公式

  需要注意：dp[i]\[1]，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

  达到dp[i][1]状态，有两个具体操作：

  - 操作一：第i天买入股票了，那么dp[i]\[1] = dp[i-1]\[0] - prices[i]
  - 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i]\[1] = dp[i - 1]\[1]

  那么dp[i][1]究竟选 dp[i-1]\[0] - prices[i]，还是dp[i - 1]\[1]呢？

  一定是选最大的，所以 dp[i]\[1] = max(dp[i-1]\[0] - prices[i], dp[i - 1]\[1]);

  同理dp[i]\[2]也有两个操作：

  - 操作一：第i天卖出股票了，那么dp[i]\[2] = dp[i - 1]\[1] + prices[i]
  - 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i]\[2] = dp[i - 1]\[2]

  所以dp[i]\[2] = max(dp[i - 1]\[1] + prices[i], dp[i - 1]\[2])

  同理可推出剩下状态部分：

  dp[i]\[3] = max(dp[i - 1]\[3], dp[i - 1]\[2] - prices[i]);

  dp[i]\[4] = max(dp[i - 1]\[4], dp[i - 1]\[3] + prices[i]);

  1. dp数组如何初始化

  第0天没有操作，这个最容易想到，就是0，即：dp[0]\[0] = 0;

  第0天做第一次买入的操作，dp[0]\[1] = -prices[0];

  第0天做第一次卖出的操作，这个初始值应该是多少呢？

  首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，

  从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。

  所以dp[0]\[2] = 0;

  第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

  第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

  所以第二次买入操作，初始化为：dp[0]\[3] = -prices[0];

  同理第二次卖出初始化dp[0]\[4] = 0;

  1. 确定遍历顺序

  从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。

  1. 举例推导dp数组

  以输入[1,2,3,4,5]为例

  ![123.买卖股票的最佳时机III](https://img-blog.csdnimg.cn/20201228181724295.png)

  大家可以看到红色框为最后两次卖出的状态。

  现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。

  所以最终最大利润是dp[4]\[4]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][5];
        dp[0][0] = 0;
        dp[0][1] = dp[0][3]= -prices[0];
        dp[0][2] = dp[0][4] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[len-1][4];
    }
}
```

